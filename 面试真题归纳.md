# 面试真题归纳

## 项目相关问题

### 你的秒杀项目还能在哪里优化？同理，你的记账软件项目还能在哪里再优化？



### 秒杀系统进行了压力测试吗？测试成功率怎么样？



### 项目中的全局异常在哪个维度？



### 如何保障数据库和redis缓存的一致性

- 不一致出现一般是在高并发场景。例如redis中已存在缓存数据，则需要同时修改db和redis中的数据，但是二者修改操作的执行必然存在先后顺序。在高并发的场景下，就有可能产生数据不一致的情况。
- 异步更新缓存、缓存延时双删、删除重试机制、读取binlog异步删除（数据库会把操作信息记录在 binlog 日志中；使用 canal 订阅 binlog 日志获取目标数据和 key；缓存删除系统获取 canal 的数据，解析目标 key，尝试删除缓存。如果删除失败则将消息发送到消息队列；缓存删除系统重新从消息队列获取数据，再次执行删除操作。
- **读缓存**最佳实践：先读缓存，命中则返回；未命中则查询数据库，再写到缓存中。
- **写缓存**最佳实践：
  - 先写数据库，再操作缓存；
  - 直接删除缓存，而不是修改，因为**当缓存的更新成本很高，需要访问多张表联合计算，建议直接删除缓存，而不是更新，另外，删除缓存操作简单，副作用只是增加了一次 chache miss，建议大家使用该策略。**

## 知识题

### Redis缓存击穿、缓存穿透、缓存雪崩

#### 缓存击穿

**高并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那一份已经过期，后端需要从 DB 从加载数据并写到 Redis。**

**关键字：单一热点数据、高并发、数据失效**

由于高并发，可能会把 DB 压垮，导致服务不可用。

##### 解决方案

###### 1、过期时间 + 随机值

对于热点数据，不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis 高吞吐量性能利用起来。或者过期时间再加一个随机值。让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力

###### 2、预热

预先把热门数据提前存入 Redis 中，并设热门数据的过期时间超大值。

###### 3、使用锁

当发现缓存失效的时候，不是立即从数据库加载数据。而是先获取分布式锁，获取锁成功才执行数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执行数据库查询操作，当前线程睡眠一段时间在重试。这样只让一个请求去数据库读取数据。

#### 缓存穿透

意味着有特殊请求在查询一个不存在的数据，即数据不存在 Redis 也不存在于数据库。导致**每次请求都会穿透到数据库**，缓存成了摆设，对数据库产生很大压力从而影响正常服务。

##### 解决方案

- **缓存空值**：当请求的数据不存在 Redis 也不存在数据库的时候，设置一个缺省值（比如：None）。当后续再次进行查询则直接返回空值或者缺省值。
- **布隆过滤器（BloomFilter）**：在数据写入数据库的同时将这个 ID 同步到到布隆过滤器中，当请求的 id 不存在布隆过滤器中则说明该请求查询的数据一定没有在数据库中保存，就不要去数据库查询了。**布隆过滤器判断存在不一定真的存在，但判断不存在一定不存在**

#### 缓存雪崩

缓存雪崩指的是**大量的请求无法在 Redis 缓存系统中处理，请求全部打到数据库，导致数据库压力激增**，甚至宕机。

出现该原因主要有两种：

- **大量热点数据**同时过期，导致大量请求需要查询数据库并写到缓存；（**缓存雪崩是发生在大量数据同时失效的场景，而缓存击穿（失效）是在某个热点数据失效的场景，这是他们最大的区别。**）
- Redis 故障宕机，缓存系统异常。

##### 解决方案

- 过期时间添加随机值

- 接口限流：在**业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。**当访问的不是核心数据的时候，在查询的方法上加上**接口限流保护**。

- 对于Redis缓存系统故障导致的缓存雪崩的解决方案：

  - 服务熔断和接口限流；

  **服务熔断就是当从缓存获取数据发现异常，则直接返回错误数据给前端，防止所有流量打到数据库导致宕机。**

  **服务熔断和限流属于在发生了缓存雪崩，如何降低雪崩对数据库造成的影响的方案。**

  - 构建高可用缓存集群系统。

  如果 Redis 的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。



### 定时任务的实现方式（每种方式大概的内容）

单点定时任务

- JDK原生
- Spring Task
- 基于 Redis 实现

分布式定时任务

- 引入分布式定时任务组件or中间件

### Session

**存储位置**：session是存放在**服务器内存**中的一个对象；而cookie是存放在**客户端电脑中**的一个磁盘文件。

**存储容量**：单个cookie保存的数据一般不超过4KB，一个站点最多保存20个cookie；对于session来说并没有上限，但出于对服务器性能考虑，session内不应存放过多内容。

**存储方式**：cookie中只能保管**ASCII字符串**，并需要通过编码方式存储为Unicode字符或者二进制数据；而session中能够存储任何类型的数据，包括且不限于string、integer、list、map等。

### 为什么要用分布式事务

1、**数据库分库分表**：这是分布式事务产生的一个主要背景，随着业务量的增长，单个数据库可能无法满足性能需求，需要将数据分散到多个数据库或数据表中。

2、**应用服务化（SOA化）**：业务被拆分成多个独立的服务，每个服务都有自己的数据库。在这种情况下，跨多个服务的事务处理需要分布式事务的支持。

3、**数据一致性**：分布式事务的核心目标是确保多个参与者之间的数据保持一致。这要求所有参与者都遵循相同的操作逻辑，确保数据变更的原子性、一致性、隔离性和持久性（ACID属性）。

4、**两阶段提交（2PC）**：一种经典的分布式事务协调协议，分为准备阶段和提交阶段。在准备阶段，协调者询问所有参与者是否可以提交事务；在提交阶段，协调者根据参与者的响应来决定是否提交事务。

5、**三阶段提交（3PC）**：两阶段提交的改进版，增加了一个准备阶段，用于解决协调者在准备阶段发生故障导致的问题。

6、**故障恢复**：当分布式系统中的某个节点发生故障时，分布式事务机制能够恢复事务的状态，确保数据的正确性和一致性。

7、**扩展性和性能**：分布式事务通过将事务操作分散到多个节点上，提高了系统的扩展性和性能，能够处理更多的并发请求。
