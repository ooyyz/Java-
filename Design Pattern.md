# 设计模式

- [设计模式的七大原则/面向对象的七大原则](#设计模式的原则)
- 三大类设计模式包括：创建型模式、结构型模式、行为型模式，展开共25种，当然常用的是23种；不过还有一种比较罕见的设计模式：**J2EE模式**
- 创建型模式
    - 创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象,这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活,包括：
        - [工厂模式](#工厂模式)
        - [抽象工厂模式](#抽象工厂模式)
        - [单例模式](#单例模式)
        - [建造者模式](#建造者模式)
        - [原型模式](#原型模式)
- 结构型模式
    - 结构型模式关注类和对象的组合，会更加一依赖于继承去实现，包括：
        - [适配器模式](#适配器模式)
        - [桥接模式](#桥接模式)
        - [组合模式](#组合模式)
        - [装饰器模式](#装饰器模式)
        - [外观模式](#外观模式)
        - [享元模式](#享元模式)
        - [代理模式](#代理模式)
        - [过滤器模式](#过滤器模式)
- 行为型模式
    - 行为型模式特别关注对象之间的通信，包括：
        - [责任链模式](#责任链模式)
        - [命令模式](#命令模式)
        - [解释器模式](#解释器模式)
        - [迭代器模式](#迭代器模式)
        - [中介者模式](#中介者模式)
        - [备忘录模式](#备忘录模式)
        - [观察者模式](#观察者模式)
        - [状态模式](#状态模式)
        - [策略模式](#策略模式)
        - [模板模式](#模板模式)
        - [访问者模式](#访问者模式)
        - [空对象模式](#空对象模式)
- J2EE模式(待完成)
    - J2EE模式特别关注表示层，J2EE模式是由 Sun Java Center 鉴定的，包括：
        - [参考](https://www.runoob.com/design-pattern/visitor-pattern.html)
        - [MVC模式](#MVC模式)
        - [业务代表模式](#业务代表模式)
        - [组合实体模式](#组合实体模式)
        - [数据访问对象模式](#数据访问对象模式)
        - [前端控制器模式](#前端控制器模式)
        - [拦截过滤器模式](#拦截过滤器模式)
        - [服务定位器模式](#服务定位器模式)
        - [传输对象模式](#传输对象模式)

------

### 设计模式的原则
- 单一职责原则
    - 一个类只负责一项职责
- 开闭原则
    - 对扩展开放，对修改关闭，也就是说一个类、函数、模块应该允许扩展功能但不允许修改
- 里氏替换原则
    - 是指在继承的时候，子类可以扩展父类的功能，但不要修改父类的功能
- 依赖倒转原则
    - 高层模块不要依赖于底层模块，两者都应该依赖于抽象。进一步说就是抽象不要依赖于细节，而应该反过来细节来依赖抽象
    - 这个核心就是面向接口编程
    - eg：产品经理想要实现一个业务逻辑的时候，应该先提供想要的接口，让程序员去对底层数据库去编程以实现这个接口，而不是等这个数据库操作都操作完了再填上这个接口是什么。
- 接口隔离原则
    - 尽量细化接口，建立单一接口，不要接口太庞大臃肿
- 迪米特法则
    - 又称最少知识原则，指一个对象应该对其它对象保持最少的了解和相关
- 组合/聚合原则
    - 尽量使用组合和聚合而非使用继承的关系来达到复用的效果

### 工厂模式
- 工厂模式最常用的设计模式之一，属于创建型模式
- 工厂模式使得我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
- 也就是它会定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，而使用方只需要调用这个接口就创建了对应类型的对象
- 所以工厂模式使创建对象的过程延迟到子类进行。
- 优点：
    - 一个调用者想创建一个对象，只要知道其接口名称就可以了。
    - 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
    - 能屏蔽产品的具体实现，调用者只关心产品的接口。
- 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。

### 抽象工厂模式
- 抽象工厂模式是围绕一个超级工厂创建其他工厂。该超级工厂也被称为其他工厂的工厂。
- 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，而不是具体的对象
- 使用者先调用接口生成工厂，然后再通过某个生成的工厂去创建对象，每个生成的工厂都能按照工厂模式提供对象。
- 适用场景举例：
    - QQ秀换装的时候，通常一换就是包括衣服和裤子一整套的换，那么这里每套服装就是一个工厂，QQ秀选择的窗口就是超级工厂
- 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
- 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

### 单例模式
- 单例模式是最简单的设计模式之一
- 单例模式只涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。
- 这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
- 需要注意的是：
    - 单例类只能有一个实例
    - 单例类必须自己创建自己的唯一实例
    - 单例类必须给所有其他对象提供这一实例，相当于一个全局的对象
- 优点： 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例.
- 缺点：没有接口也不能继承，以及功能单一

### 建造者模式
- 建造者模式使用多个简单的对象一步一步构建成一个复杂的对象
- 主要解决一个复杂对象的创建工作
    - 这个复杂的对象通常由各个部分的子对象用一定的算法构成；
    - 由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
- 优点：
    - 建造者独立，易扩展。
    - 便于控制细节风险。
- 缺点：
    - 产品必须有共同点，范围有限制。
    - 如内部变化复杂，会有很多的建造类。
- 使用场景：
    - 需要生成的对象具有复杂的内部结构。
    - 需要生成的对象内部属性本身相互依赖。
- 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

### 原型模式
- 原型模式是用于创建重复的对象，同时又能保证性能
- 使用场景就是当直接创建对象的代价比较大时，采用这种模式
- 具体实现在JAVA中就是继承Cloneable类，重写clone()方法
- 优点：
    - 性能提高。
    - 逃避构造函数的约束。
- 缺点：
    - 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。
    - 必须实现 Cloneable 接口。

### 适配器模式
- 适配器模式是作为两个不兼容的接口之间的桥梁。
- 适用于主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的这种情况
- 主要通过继承或依赖来实现
- 优点：
    - 可以让任何两个没有关联的类一起运行。
    - 提高了类的复用。
    - 增加了类的透明度。
    - 灵活性好。
- 缺点：
    - 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，
- 因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

### 桥接模式
- 桥接模式是用于把抽象化与实现化解耦，使得二者可以独立变化。
- 也就是系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系时，通过桥接模式可以使它们在抽象层建立一个关联关系
- 主要适用于：在有多种可能会变化的情况下，用继承会造成类混乱问题，扩展起来不灵活，就采用桥接模式。
- 举例：
    - 灵魂和肉体，前者相当于抽象化，后者相当于实现化。灵魂通过功能的委派，调用肉体对象的功能，使得灵魂和肉体可以动态地选择。
- 优点：
    - 抽象和实现的分离。
    - 优秀的扩展能力。
    - 实现细节对客户透明。
- 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

### 过滤器模式
- 过滤器模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。

### 组合模式
- 又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象去实现
- 这种模式创建了一个包含自己对象组的类，该类也提供了修改相同对象组的方式。
- 举例：
    - 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。
- 优点：
    - 高层模块调用简单。
    - 节点自由增加。
- 缺点：在使用组合模式时，它的类依赖于其它类的实现，可以说高层依赖于低层的实现，而不是接口，违反了依赖倒置原则。

### 装饰器模式
- 装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。
- 这种模式完美地满足了开闭原则，适用于在不想增加很多子类的情况下扩展类以及动态增加功能，动态撤销。
- 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
- 缺点：多层装饰比较复杂。

### 外观模式
- 外观模式隐藏了系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。
- 主要适用于降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。
- 优点：
    - 减少系统相互依赖。
    - 提高灵活性。
    - 提高了安全性。
- 缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

### 享元模式
- 享元模式主要用于减少创建对象的数量，以减少内存占用和提高性能。
- 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，再创建新对象。
- 主要适用于在有大量对象时，有可能会造成内存溢出，我们想把其中共同的部分抽象出来的这种情况
- 优点：大大减少对象的创建，降低系统的内存，使效率提高。
- 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

### 代理模式
- 代理模式就是用一个类代表另一个类的功能，在这模式中，会创建具有现有对象的对象，以便向外界提供功能接口
- 主要用于解决直接访问对象时会带来意外的问题的这种场景
- 优点：
    - 职责清晰。
    - 高扩展性。
    - 智能化。
- 缺点：
    - 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。
    - 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

### 责任链模式
- 责任链模式避免了请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
- 在这种模式中职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。
- 优点：
    - 降低耦合度。它将请求的发送者和接收者解耦。
    - 简化了对象。使得对象不需要知道链的结构。
    - 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。
    - 增加新的请求处理类很方便。
- 缺点：
    - 不能保证请求一定被接收。
    - 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。
    - 可能不容易观察运行时的特征，有碍于除错。

### 命令模式
- 命令模式是一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象
- 适用于需要对行为进行记录、撤销或重做、事务等处理时，可以将行为封装成一个对象当做一个命令去传递
- 优点：
    - 降低了系统耦合度。
    - 新的命令可以很容易添加到系统中去。
- 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。

### 解释器模式
- 解释器模式提供了评估语言的语法或表达式的方式
- 这种模式实现了一个表达式接口，该接口解释一个特定的上下文
- 这种模式被用在 SQL 解析、符号处理引擎等。
- 优点：
    - 可扩展性比较好，灵活。
    - 增加了新的解释表达式的方式。
    - 易于实现简单文法。
- 缺点：
    - 可利用场景比较少。
    - 对于复杂的文法比较难维护。
    - 解释器模式会引起类膨胀。
    - 解释器模式采用递归调用方法。

### 迭代器模式
- 迭代器模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
- 适用于遍历一个聚合对象的场景
- 优点：
    - 它支持以不同的方式遍历一个聚合对象。
    - 迭代器简化了聚合类。
    - 在同一个聚合上可以有多个遍历。
    - 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。
- 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

### 中介者模式
- 中介者模式是用来降低多个对象和类之间的通信复杂性。
- 这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。
- 使用场景是系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象的情况
- 优点：
    - 降低了类的复杂度，将一对多转化成了一对一。
    - 各个类之间的解耦。
    - 符合迪米特原则。
- 缺点：中介者会庞大，变得复杂难以维护。

### 备忘录模式
- 备忘录模式保存一个对象的某个状态，以便在适当的时候恢复对象
- 这种模式主要用于在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
- 优点：
    - 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。
    - 实现了信息的封装，使得用户不需要关心状态的保存细节。
- 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。

### 观察者模式
- 当对象间存在一对多关系时，则使用观察者模式，这样当一个对象被修改时，则会自动通知依赖它的对象
- 适用于一个对象状态改变时需要给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作的场景
- 优点：
    - 观察者和被观察者是抽象耦合的。
    - 建立一套触发机制。
- 缺点：
    - 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
    - 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
    - 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

### 状态模式
- 在状态模式中，类的行为是基于它的状态改变的。
- 在这种模式中，需要创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象
- 适用于对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为的场景
- 优点：
    - 封装了转换规则。
    - 枚举可能的状态，在枚举状态之前需要确定状态种类。
    - 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。
    - 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。
    - 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。
- 缺点：
    - 状态模式的使用必然会增加系统类和对象的个数。
    - 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。
    - 状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

### 空对象模式
- 在空对象模式中，一个空对象取代 NULL 对象实例的检查
- Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。
- 在空对象模式中，需要创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。

### 策略模式
- 在策略模式中，一个类的行为或其算法可以在运行时更改。
- 适用于可以方便地切换算法的场景，在策略模式中，我们就会把这些算法封装成类去切换使用
- 优点：
    - 算法可以自由切换。
    - 避免使用多重条件判断。
    - 扩展性良好。
- 缺点：
    - 策略类会增多。
    - 所有策略类都需要对外暴露。

### 模板模式
- 在模板模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
- 适用于一些方法通用，却在每一个子类都重新写了这一方法的场景
- 优点：
    - 封装不变部分，扩展可变部分。
    - 提取公共代码，便于维护。
    - 行为由父类控制，子类实现。
- 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

### 访问者模式
- 在访问者模式中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。
- 优点：
    - 符合单一职责原则。
    - 优秀的扩展性。
    - 灵活性。
- 缺点：
    - 具体元素对访问者公布细节，违反了迪米特原则。
    - 具体元素变更比较困难。
    - 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。
