# 数据库

* 数据库基础
    * [事务的概念和特性以及实现原理？](#事务的概念和特性以及实现原理)
    * [会出现哪些并发一致性问题？](#会出现哪些并发一致性问题)
    * [数据库的四种隔离级别以及如何实现？](#数据库的四种隔离级别以及如何实现)
    * [RR隔离级别下如何避免幻读?](#RR隔离级别下如何避免幻读)
    * [什么是乐观锁和悲观锁？](#什么是乐观锁和悲观锁)
    * [常见的封锁类型？](#常见的封锁类型)
    * [什么是三级封锁协议？](#什么是三级封锁协议)
    * [什么是 MVCC？](#什么是-mvcc)
        * [MVCC的实现是基于什么的（MVCC是怎么实现的）]
    * [数据库的范式？](#数据库的范式)
    * [列举几种表连接方式？](#列举几种表连接方式)
    * [什么是存储过程？有哪些优缺点？](#什么是存储过程有哪些优缺点)
    * [Drop/Delete/Truncate的区别？](#DropDeleteTruncate的区别)
    * [什么是视图？什么是游标？](#什么是视图什么是游标)
* MySQL
    * [SQL语句的执行过程](#SQL语句的执行过程)
        * redo log日志和bin log日志的区别?
        * 在update过程中,mysql突然宕机,会发生什么情况?
    * [主键的设计原则](#主键的设计原则)
    * [数据库索引的实现原理（B+树）](#数据库索引的实现原理b树)
    * [使用索引的优点](#使用索引的优点)
    * [哪些情况下索引会失效？](#哪些情况下索引会失效)
    * [在哪些地方适合创建索引？](#在哪些地方适合创建索引)
    * [索引的分类？](#索引的分类)
    * [MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？](#MySQL的两种存储引擎-InnoDB-和-MyISAM-的区别)
    * [如何优化数据库？](#如何优化数据库)
    * [什么是主从复制？实现原理是什么？](#什么是主从复制实现原理是什么)
* MySQL面试题
    * [MySQL一条SQL语句的长度大小限制?](#MySQL一条SQL语句的长度大小限制)
    * [MySQL行长度限制?](#MySQL行长度限制)
    * [数据库自增ID用完了会怎样?](#数据库自增ID用完了会怎样)
    * [数据库如果数据过多怎么办](#数据库如果数据过多怎么办)
* [SQL代码复习](#SQL代码复习)

------

#### 事务的概念和特性以及实现原理？
<details><summary>展开</summary>

- 概念：事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束
- **特性**（ACID）：
    - **原子性**（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；
    - **一致性**（Consistency）：事务的执行必须使数据库保持一致性状态。一致性状态就是指数据库处于一个合法的状态并且所有事务对同一个数据的读取结果都是相同的，这里的合法指的是语义上的合法而不是语法上的合法，语义上的合法也就是说符合逻辑上的正确；
    - **隔离性**（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）；
    - **持久性**（Durability）：一旦事务提交成功，对数据的修改是永久性的
- **实现原理**:
    - **原子性**：通过undo log回滚日志实现的。实现原子性的关键是事务回滚的时候，能完整地撤销事务做出的修改。InnoDB实现回滚，靠的就是undo log，当事务对数据库修改的时候，InnoDB会生成对应的undo日志，然后回滚的时候根据undo日志做相反的修改操作(比如原本是insert的，现在就delete)
    - **一致性**：一致性的实现是通过其它三个特性的实现而实现的，也就是说在事务的特性中，其它三个特性是手段，而一致性是目的，所以一致性也可以说关键的特性。
    - **隔离性**：隔离性的实现基于两种手段——一个是锁机制，另一个是MVCC
        - 如果是写操作，通过锁机制保证事务隔离，锁机制就是指共享锁、排它锁、意向锁这些，如果数据被上锁了，其它事务不能操作这个数据，而如果要操作这个数据就要加锁
        - 如果是读操作，分为不加锁读和加锁读：
            - 不加锁读通过MVCC读，是在RR隔离级别下的
            - 加锁读通过next-key锁，从而实现隔离，没有next-key的话只能避免脏读和不可重复读，有了next-key所的话就能避免幻读
                - next-key锁（也就是next-key lock）是行锁的一种，实现相当于record lock(记录锁) + gap lock(间隙锁)；其特点是不仅会锁住记录本身(record lock的功能)，还会锁定一个范围(gap lock的功能)。因此，加锁读同样可以避免脏读、不可重复读和幻读，保证隔离性。
    - **持久性**：通过redo log重做日志实现的。
        - 由于MySQL对数据的修改是先将数据加载到内存上，再到磁盘上进行修改，如果在第二步到写磁盘上的时候发生宕机重启就会出现破坏持久性的问题。而MySQL是通过redo log日志解决这个问题的。
        - 当对数据进行修改的时候，数据库会先在redo log中记录操作，同时写入内存，那么如果当写入磁盘的时候宕机重启了，就可以通过redo log进行恢复数据，然后再根据bin log决定是回滚还是提交
        </details>

#### 会出现哪些并发一致性问题？
<details><summary>展开</summary>

- **丢失修改**：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；
- **脏读**（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；
- **不可重复读**（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对**update**操作）；
- **幻读**（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对**insert/delete**操作）
</details>

#### 数据库的四种隔离级别以及如何实现？
<details><summary>展开</summary>

- **未提交读**（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；
- **提交读**（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；
- **可重复读**（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读；
- **可串行化**（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。

<details><summary>四种隔离级别如何实现</summary>

- **未提交读**：不需要做什么就达到了，这时候只有写操作要加锁
- **提交读**：通过MVCC实现，这时候的锁不包含gap锁，对于写锁，事务只记录update和delete记录的写锁；然后MVCC的ReadView是语句级别的快照，也就是每条语句执行前获取ReadView，可见性判断是基于语句级别的
- **可重复读**：通过MVCC和锁机制实现：这时候MVCC的ReadView是在事务开始的时候创建的，当读一条记录的时候，遍历undo log的版本链和ReadView判断可见性找到第一个对当前事务可见的版本，读这个版本；这时候写操作和显式的加锁的读操作需要加锁，对于数据是否又索引加锁操作不同:
    - 有索引：对于索引上有唯一约束且为等值条件的情形，不用GAP LOCK，只锁定索引记录。对于其它情形，使用GAP LOCK，相当于谓词锁。
    - 没有索引：由于MySQL没有实现通用的谓词锁，这时就相当于锁全表。
- **可串行化**：数据库强制实行2PL两段锁协议，也就是第一阶段Growing申请锁，第二阶段Shrinking仅允许释放锁。
</details>

</details>

#### RR隔离级别下如何避免幻读?
<details><summary>展开</summary>

- 通过next-key锁：next-key锁（也就是next-key lock）是行锁的一种，实现相当于record lock(记录锁) + gap lock(间隙锁)；其特点是不仅会锁住记录本身(record lock的功能)，还会锁定一个范围(gap lock的功能)。因此，加锁读同样可以避免脏读、不可重复读和幻读，保证隔离性。
- 当然RR隔离级别下的读还是要通过MVCC
</details>

#### 什么是乐观锁和悲观锁？
<details><summary>展开</summary>

- 悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于**数据更新比较频繁**的场景；
- 乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于**读多写少**的场景。乐观锁的实现方式有：
    - 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；
    - 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新
    </details>

#### 常见的封锁类型？
<details><summary>展开</summary>

意向锁是 InnoDB 自动加的， 不需用户干预。
对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB
会自动给涉及数据集加排他锁（X)；
对于普通 SELECT 语句，InnoDB 不会加任何锁；
事务可以通过以下语句显式给记录集加共享锁或排他锁：
共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁
- **排它锁**（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；
- **共享锁**（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁
- **意向锁**（Intention Locks）：
    - 一个事务在获得某个**数据行**对象的 S 锁之前，必须先获得**整个表**的 IS 锁或更强的锁；
    - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；
    - IS/IX 锁之间都是兼容的；
    - 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了

锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性

<details>
<summary>封锁粒度的概念</summary>

MySQL 中提供了两种封锁粒度：**行级锁**以及**表级锁**。

封锁粒度小：

- 好处：锁定的数据量越少，发生锁争用的可能就越小，系统的**并发程度**就越高；
- 坏处：**系统开销**大（加锁、释放锁、检查锁的状态都需要消耗资源）
</details>

<details>
<summary>MySQL加锁</summary>

```
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```
</details>
</details>

#### 什么是三级封锁协议？
<details><summary>展开</summary>

- 一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；
- 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；
- 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）
</details>

#### 什么是 MVCC？
<details><summary>展开</summary>

多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储**创建版本号**和**删除版本号**。

- 创建版本号：创建一个数据行时的事务版本号（**事务版本号**：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）；
- 删除版本号：删除操作时的事务版本号；
- 各种操作：
    - 插入操作时，记录创建版本号；
    - 删除操作时，记录删除版本号；
    - 更新操作时，先记录删除版本号，再新增一行记录创建版本号；
    - 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）

##### MVCC的实现是基于什么的（MVCC是怎么实现的）？
<details><summary>展开</summary>

- MVCC基于三个内容实现，分别是隐藏列、undo log的版本链和ReadVieW:
- 隐藏列就是数据库的每一行数据都有一个隐藏列属性，记录了事务的ID和指向undo log的指针，从而关联其这一行数据和对应事务以及undo log回滚日志
- undo log的版本链就是由于隐藏列有指向undo log的指针，而undo log也会指向更早版本的undo log，从而形成一条版本链
- ReadVieW是某一个时间点，事务执行状态的一个快照，可以用来判断事务的可见性。
- 那么通过隐藏列和undo log的版本链，数据库可以恢复到之前的版本，然后根据ReadView知道要恢复到哪个版本，从而实现读不同版本下的读数据，这就是MVCC
</details>

##### 提交读RC隔离级别和可重复读RR隔离级别下MVCC是怎么工作的？
<details>
<summary>快照读与当前读</summary>

使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销：

```
select * from table ...;
```

当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：

```
select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update;
delete;
```

</details>
</details>

#### 数据库的范式？
<details><summary>展开</summary>


- **第一范式**（1NF，Normal Form）：**属性不应该是可分的**。举例：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话...如果将“移动电话”作为一个属性，就符合1NF；
- **第二范式** 2NF：每个非主属性**完全依赖**于主属性集（候选键集）；
    - B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集；
    - 主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性；
    - 可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余；
    满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；
- **第三范式** 3NF：在 2NF 的基础上，非主属性**不传递依赖**于主属性
    - 传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A；
    - 3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。
    必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；
<details>
<summary>不符合范式会出现哪些异常？</summary>

- 冗余数据：某些同样的数据多次出现（如学生姓名）；
- 修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改；
- 删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）；
- 插入异常：无法插入（插入一个还没有课程信息的学生）
</details>
</details>

#### 列举几种表连接方式？
<details><summary>展开</summary>


![SQL连接](_v_images/20191207081711185_20242.png)

- 内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集
    - 自然连接：只考虑属性相同的元组对；
    - 等值连接：给定条件进行查询
- 外连接（Outer Join）
    - 左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；
    - 右连接：和左连接相反；
    - 全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据
- 交叉连接（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）
</details>

#### 什么是存储过程？有哪些优缺点？
<details><summary>展开</summary>

存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。

优点：
- 预先编译，而不需要每次运行时编译，提高了数据库执行**效率**；
- 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以**减少网络通信量**；
- 具有**可复用性**，减少了数据库开发的工作量；
- **安全性高**，可以让没有权限的用户通过存储过程间接操作数据库；
- 更**易于维护**

缺点：
- **可移植性差**，存储过程将应用程序绑定到了数据库上；
- **开发调试复杂**：没有好的IDE；
- **修改复杂**，需要重新编译，有时还需要更新程序中的代码以更新调用
</details>

#### Drop/Delete/Truncate的区别？
<details><summary>展开</summary>

- **Delete**用来删除表的全部或者**部分数据**，执行delete之后，用户**需要提交**之后才会执行，会触发表上的DELETE**触发器**（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；
- **Truncate**删除表中的所有数据，这个操作**不能回滚**，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；
- **Drop**命令从数据库中**删除表**，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器；

<details>
<summary>什么是触发器？</summary>

触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于**保证数据完整性**（比如可以检验或转换数据）。
</details>

<details>
<summary>有哪些约束类型？</summary>

约束（Constraint）类型：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束。
</details>
</details>

#### 什么是视图？什么是游标？
<details><summary>展开</summary>

- 视图：从数据库的基本表中通过查询选取出来的数据组成的**虚拟表**（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处：
    - 通过只给用户访问视图的权限，保证数据的**安全性**；
    - **简化**复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）；
- 游标（Cursor）：用于定位在查询返回的**结果集的特定行**，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。

------
</details>

#### SQL语句的执行过程

<details><summary>展开</summary>

- 首先SQL语句要分成两种，一种是查询语句，一种是更新语句（包括插入删除等会改变数据库的操作）
- SQL**查询语句**的执行过程分为5步:
    - 首先是**连接器**将客户端和服务端建立链接，获取连接用户的权限并检查，如果没有权限，就返回错误
    - 第二步是**查询缓存**，这里的缓存是把整个SQL语句作为键在内存中缓存，如果查找到有相应的缓存，就直接返回结果，不执行下一步；不过查询缓存在MySQL8.0版本以后就移除了
    - 第三步是**解析和预处理**
        - 解析器或者说分析器会通过关键字对SQL语句进行解析，生成解析树，通过MySQL语法规则进行验证和解析查询
        - 预处理器会根据一些MySQL规则进行进一步检查解析树是否合法，例如检查数据表和数据列是否存在等
    - 第四步是**优化器（CBO）确定执行方案**，优化器会根据**统计信息**和**代价模型**计算每个执行计划的Cost，选择Cost最小也就是效率最好的方案
    - 第五步就是**数据库引擎去执行这个语句**，在执行这个语句之前，会先进行权限校验，如果没有权限就会返回错误，否则就调用数据库引擎接口，让数据库引擎比如MyISAM、innoDB、NDB、memory去执行执行计划，返回结果，在返回结果前如果这个查询语句的结果可以被缓存，就会进行缓存。
        - 这个结果的返回是增量、逐步的过程，在查询生成第一条结果的时候就会开始返回
- SQL**更新语句**的执行过程，可以说是7步:
    - 这里主要是说一下采用InnoDB引擎的SQL更新语句的执行过程，更新语句需要用到两个日志redo log重做日志和bin log归档日志。
    - 然后SQL更新语句的执行过程，我的理解是更新语句是**基于查询语句**的，也就是说前4步和查询语句的执行过程一样，先查询到所在数据
    - 第5步是调用引擎API接口，写入这一行数据，然后**采用WAL策略写入relog日志**中
        - WAL策略就是先写入relog日志，同时更新内存，再在合适的时候更新到磁盘，否则每次都直接写入磁盘，IO成本太高
        - 再写入完relog日志后，relog就会进入prepare状态，然后通知server层执行器，执行完成了，随时可以提交
    - 第6步是**执行器**收到通知后，将记录**写入到binlog**
    - 第7步是**执行器**调用引擎的提交事务接口，把刚刚写入的relog改为commit提交状态，这样更新就完成了

##### redo log日志和bin log日志的区别
<details><summary>展开</summary>

- bin log是归档日志，是MySQL server层的日志
    - bin log使得数据库能够基于时间点进行恢复数据
    - 是逻辑日志，记录的是SQL语句的原始逻辑
    - 是追加写入的,没有限制大小，不会覆盖之前的日志
- redo log重做日志，是数据库引擎层的日志，也是InnoDB特有的日志
    - 用来应对异常恢复的，具有cresh-safe特性，也就是redo log可以保证MySQL异常重启的时候，未提交的事务回滚，已提交的事务安全落库
    - 是物理日志，内容是基于磁盘的
    - 具有固定大小，可以进行配置，比如配置为一组4个文件，每个文件1GB
    - 是循环写入的，写到末尾就会从头开始覆盖。
    </details>

##### 在update过程中，mysql突然宕机，会发生什么情况?
<details><summary>展开</summary>

- 如果bin log还没有写入，那么宕机重启就会直接事务回滚
- 如果bin log写入了，此时redo log也已经写入了，如果redo log还没有更新为提交状态，那么MySQL就会检查对应事务在bin log中是否完整，如果是就提交事务，否则就回滚
- 这里redo log和bin log是通过xid这个字段关联在一起的
</details>

</details>

#### 主键的设计原则

<details><summary>展开</summary>

- 主键对用户应当是没有意义的
- 主键应该是单列的，以提高连接和筛选操作的效率
- 永远也不要更新主键，因为主键的作用就是唯一表示一行
- 主键不应该包含动态变化的数据，如时间戳、创建时间列、修改时间等
- 主键应当由计算机自动生成，防止被人为修改
</details>

#### 数据库索引的实现原理（B+树）
<details><summary>展开</summary>


见数据结构部分：B树，B+树

##### 使用B树和B+树的比较
<details><summary>展开</summary>


InnoDB的索引使用的是B+树实现，B+树对比B树的好处：

- IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；
- 范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；
- 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多
</details>

##### 使用B树索引和哈希索引的比较
<details><summary>展开</summary>


哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。
</details>

#### 使用索引的优点
<details><summary>展开</summary>

- 大大加快了数据的**检索速度**；
- 可以显著减少查询中**分组和排序**的时间；
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；
- 将随机 I/O 变为**顺序 I/O**（B+Tree 索引是有序的，会将相邻的数据都存储在一起）

缺点：建立和维护索引耗费时间空间，更新索引很慢。
</details>

#### 哪些情况下索引会失效？
<details><summary>展开</summary>

- 以“%(表示任意0个或多个字符)”开头的LIKE语句；
- OR语句前后没有同时使用索引；
- 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；
- 对于多列索引，必须满足 **最左匹配原则**/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；
- 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）
</details>

#### 在哪些地方适合创建索引？
<details><summary>展开</summary>

- 某列经常作为最大最小值；
- 经常被查询的字段；
- 经常用作表连接的字段；
- 经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段
</details>

##### 创建索引时需要注意什么？
<details>
<summary>展开</summary>

- 只应建立在**小字段**上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）；
- 建立索引的字段应该**非空**，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；
- 选择**数据密度大**（唯一值占总数的百分比很大）的字段作索引
</details>

#### 索引的分类？
- 普通索引
- 唯一索引 UNIQUE：索引列的值必须唯一，但允许有空值；
- 主键索引 PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）；
- 单列索引和多列索引/复合索引（Composite）：索引的列数；
- 覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；
- 聚集（Clustered）索引/非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；
- 分区索引（？）
- 虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用

#### MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？
- InnoDB**支持事务**，可以进行Commit和Rollback；
- MyISAM 只支持表级锁，而 InnoDB 还**支持行级锁**，提高了并发操作的性能；
- InnoDB **支持外键**；
- MyISAM **崩溃**后发生损坏的概率比 InnoDB 高很多，而且**恢复的速度**也更慢；
- MyISAM 支持**压缩**表和空间数据索引，InnoDB需要更多的内存和存储；
- InnoDB 支持在线**热备份**
</details>
<details>
<summary>应用场景</summary>

- **MyISAM** 管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM；
- **InnoDB** 支持事务，并发情况下有很好的性能，基本可以替代MyISAM
</details>

<details>
<summary>热备份和冷备份</summary>

- 热备份：在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错
- 冷备份：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单
</details>

#### 如何优化数据库？
<details>
<summary>SQL 语句的优化</summary>

> 分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句，通过日志去找出IO大的SQL以及发现未命中索引的SQL

> 使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、**哪些索引被实际使用**、表之间的引用以及**被扫描的行数**等问题；

- 应尽量避免在 where 子句中使用```!=```、```<```、```>```操作符或对字段进行null值判断，否则将引擎放弃使用索引而进行全表扫描；
- 只返回必要的列：最好不要使用 SELECT * 语句；
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据；
- 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：
    - 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用；
    - 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询；
    - 减少锁竞争
    </details>

<details>
<summary>索引的优化</summary>

注意会引起索引失效的情况，以及在适合的地方建立索引
</details>

<details>
<summary>数据库表结构的优化</summary>

- 设计表时遵循**三大范式**；
- 选择合适的**数据类型**：尽可能不要存储NULL字段；使用简单的数据类型（int, varchar/ text）；
- 表的**水平切分**（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据ID范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力；
- 表的**垂直切分**：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单
</details>

<details>
<summary>系统配置的优化</summary>

- 操作系统：增加TCP支持的队列数；
- MySQL配置文件优化：缓存池大小和个数设置
</details>

<details>
<summary>硬件的优化</summary>

- 磁盘性能：固态硬盘；
- CPU：多核且高频；
- 内存：增大内存
</details>

#### 什么是主从复制？实现原理是什么？
主从复制（Replication）是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。

实现原理：
- 主服务器 **binary log dump 线程**：将主服务器中的数据更改（增删改）日志写入 Binary log 中；
- 从服务器 **I/O 线程**：负责从主服务器读取binary log，并写入本地的 Relay log；
- 从服务器 **SQL 线程**：负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性

##### 为什么要主从复制？
<details>
<summary>展开</summary>

- 读写分离：主服务器负责写，从服务器负责读
    - 缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作；
    - 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
    - 增加冗余，提高可用性
- 数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换
- 降低单个服务器磁盘I/O访问的频率，提高单个机器的I/O性能
</details>

---

# MySql面试题

#### MySQL一条SQL语句的长度大小限制?
<details><summary>展开</summary>

- sql语句的长度大小默认限制是1MB，但是可以通过设置来达到最大1GB的长度大小限制
</details>

#### MySQL行长度限制
<details><summary>展开</summary>

- MySQL中一行数据的字段总长最长不能超过65535字节，所以每个字段的允许长度先是满足该类型规定的最大长度在要满足行数据的最长长度限制。
</details>

#### 数据库自增ID用完了会怎样？
<details><summary>展开</summary>

- 如果设置了主键索引的话，会报错，主键冲突
- 如果没有设置主键主键索引的话，新增的数据会覆盖旧数据
</details>

#### 数据库如果数据过多怎么办？
<details><summary>展开</summary>

- 采用分表，可以用水平切分或者垂直切分（注意没有分列和分行这种说法，要使用专业术语）
</details>

## SQL代码复习
- select
   - select * 返回所有列，用#写注释
   - **DISTINCT**关键字:只返回不同的列（列对）不能部分作用，必须会作用于其后所有列。
       - eg:SELECT DISTINCT id,price FROM Products;#则DINSTINCT作用于(id,price)组合的不同列值对
   - **LIMIT**关键字:用于限制返回的条数
       - mysql> SELECT * FROM table LIMIT 5,10;# 检索记录行 6-15
       - mysql> SELECT * FROM table LIMIT 95,-1;# 检索记录96行到最后一行
       - mysql> SELECT * FROM table LIMIT 5;# 检索前 5 个记录行 <=> LIMIT 0,5
- 排序
   - 排序使用ORDER BY语句,默认是升序
   - ORDER BY需要放在SELECT的最后一行
   - ORDER BY可以以为显示的列作为排序关键字
   - 用例:SELECT prod_id,prod_price,prod_name FROM Products ORDER BY prod_price,prod_name; #对于检索出的列先按prod_price从小到大排序，如果Prod_price相同就按Prod_name字典序从小到大排序
   - **DESC关键字**，降序排序（默认是升序），用法:放在对应列的后面，一次只能用于一个列，eg:SELECTid,price,name FROM Products ORDER BY price DESC,name;#先按价格降序，再按名字升序
- WHERE
   - 用于选出满足条件的行，即过滤数据
   - 判断相等是=而不是==，不相等是！=
   - BETWEEN..AND关键字，找出一个范围内的数据（当然也可以通过比较符结合AND使用）
       - eg:SELECT name,price FROM Products WHERE price BETWEEN 5 AND 10;
   - 检查值是否为NULL不能通过 = NULL来判断，而是要使用IS NULL来判断
       - eg:SELECT name,price FROM Products WHERE price IS NULL;
   - AND的优先级高于OR的优先级，所以SELECT .. WHERE id = 3 OR name = 'lianghui' AND price = 5;#是先讲name = 'lianghui' 与 price = 5组合在一起考虑的，如果要实现OR先考虑，要加括号
   - **IN关键字**:IN操作符括号内的内容都要被匹配查找，满足之一即可,功能和多个OR相当。
       - eg:SELECT name,price FROM Products WHERE id IN('lianghui1','lianghui2');
   - **NOT关键字**:用于否定其后的内容，相当于反义
       - eg:SELECT name,price FROM Products WHERE NOT id IN('A','B','C') ;
   - **LIKE关键字**:表明要使用正则去匹配
       - %是通配符，表示任何字符出现任何次数
           - eg:SELECT * WHERE id LIKE 'FISH%';#以FISH开头的id
           - eg:SELECT * WHERE id LIKE '%FISH%';#中间含有FISH的id
           - eg:SELECT * WHERE id LIKE 'b%@qq.com';#b开头的QQ邮箱为id的
           - 需要注意的是 SELECT * WHERE idLIKE '%';#并不会匹配NULL的列，所以可以用这个来筛选出非NULL列
       - _类似于%，区别在于只匹配单个任意字符，而%是任意多个任意字符
       - []用于指定[]内的字符集，注意只能匹配[]中的一个，即匹配的个数只是一个
           - eg:SELECT * WHERE id LIKE '[ab][cd]%';#表示以ac、ad、bc、bd开头的id
           - 和^字符连用则表示相反的用法，即不在[]集合内的单个字符eg:[^JM]表示不是J也不是M的单个字符
- 函数
    - RTRIM():删去值右边的空格、LTRIM():删去值左边的空格、TRIM():删去值左右两边的空格
    - UPPER():将值中的字母都转换成大写字母;LOWER():..都转成小写字母
    - LENGTH():返回字符串的长度
    - AVG():传入参数是列名，返回该列的值的平均值，只能用于单个列
    - COUNT():计算满足条件的行的数目,例如COUNT( * )、COUNT()就是计算行的总数
        - COUNT()会忽略值为NULL的列而COUNT(*)不会
        -
