# Redis

​	启动redis

```
redis-server [--port 6379]
```

​	**Redis**，远程字典服务Remote Dictionary Server，Key-Value数据库。

​	与MySQL不同，Redis存在内存中，读写速度非常快，被广泛应用于缓存，也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案。

### Redis的基本数据类型

- String 字符串
- Hash 哈希
- List 列表
- Set 集合
- zset 有序集合
- 还有三种特殊的数据结构类型：Geospatial、Hyperloglog、Bitmap

## 数据结构

### 1.字符串


- redis中的字符串是动态字符串,叫SDS
- **redis中用到sds的地方**：1.字符串对象：除了字符串值对象外,所有的键值对的键都是字符串对象；2.AOF持久化的输入缓冲区是用SDS实现的
- **SDS的内部结构**：<br>(i) buf数组,是一个char类型数组,记录字符串内容。<br>(ii) free属性,int类型,记录buf数组中没有使用的字节的数量。<br>(iii) len属性记录已经使用的字节数量。
- **SDS和C字符串的区别**：
    - C字符串需要**O（n）**获取字符串**长度**；而SDS只需要**O（1）**获取字符串**长度**。
    - C字符串API操作**不安全**,可能会造成缓冲区溢出；而SDS API操作**安全**,因为在修改字符串前,会先判断会不会造成字符串缓冲区溢出,如果会的话就会先扩展字符串再修改。
    - SDS的**内存重分配**次数比C字符串**少**,这个得益于两个策略:
        - 第一个是空间预分配策略,就是API对字符串进行扩展的时候,会分配额外的未使用空间,分配空间的大小取决于SDS的长度：如果SDS的长度小于1MB,那么分配的大小就是同样长度的字符串len属性的长度；如果SDS的长度大于1MB,那么分配的大小就是1MB。
        - 第二个是惰性空间释放策略,API在对字符串进行缩短操作的时候,不会释放空闲的未使用空间,而是通过free属性记录未保存的空间长度,以便进行扩展的时候就不用再重分配空间了。（当然API也支持手动释放未保存空间的操作）
    - SDS buf数组保存的**数据类型**比C字符串**更丰富**。C字符串只能保存ASCII数据,且不能保存空字符,C字符串遇到的第一个空字符会被视作字符串的结束标志；而SDS不仅能保存ASCII数据,还能保存空字符,以及图片、音频等二进制数据,更加丰富。
    - C字符串相较于SDS字符串的唯一好处是,C字符串能使用**全部**的**string.h**库中的函数,而SDS只能兼容<b部分**string.h库中的函数。
    </details>
<details><summary>2.链表</summary>

- Redis中的链表是list结构体,里面有指向表头的指针head,和指向表尾的指针tail,类型是listnode类型。然后还有一个记录所含节点数的len属性,是unsigned long类型的,以及三个成员函数：dup复制节点函数、free释放节点函数和match对比节点函数,类型都是void*无类型指针,目的是为了实现链表的多态。
- 然后链表的每个节点listnode串联成链表,然后这链表是双端无环,也就是每个节点都有指向前一个节点的prev指针和指向后一个节点的next指针。最后节点存储是值是void*无类型指针,指向存储的值对象,也是为了实现多态。
</details>
<details><summary>3.字典</summary>

- Redis中的字典的实现我自己把它分为三层：最低层是单向链表,也可以说哈希表节点,链表中的每个元素都是一个键值对,每个单向链表就是一个哈希表节点；哈希表节点数组构成哈希表,所以第二层是哈希表；最后由两个哈希表形成一个字典,这才形成了顶层结构字典。
- 关于Redis字典添加键值对,Redis在添加一个键值对的时候,字典通过哈希算法往哈希表中添加节点。期间根据字典维护的负载因子判断是否进行rehash,也就是重新散列。
- **下面我可以来为刚刚提到的每个概念进行展开讲解包括各层结构、使用哈希算法插入键值对的一些关键点还有rehash的方式**:
- 首先是最外层的字典,他是一个dict结构体：
    - 其中type属性是一个指向dictType结构的指针,这个dictType结构封装了各种操作特定类型的键值对的函数。
    - dict结构体中还有一个private属性,这个属性保存了需要传给dictType结构中特定类型函数的可选参数。
    - 另外dict结构体中还含有一个rehashidx属性,记录rehash进行时的当前索引,当没有进行rehash时,它的值是-1
    - 除此之外就是他的核心结构:ht数组,是一个哈希表数组,且数组大小固定是2,也就是说存储两个哈希表——哈希表[0]和哈希表[1],类型都是dictht结构体,哈希表0用于存储键值对,哈希表1用于rehash。
- 然后是第二层——哈希表,也就是刚刚讲到的dictht结构体:
    - dictht结构体有三个属性:size、sizemask、used,都是unsigned long类型的。其中size记录哈希表的大小,sizemask记录哈希表大小掩码用于计算加入键值对时的索引,sizemask总是等于size-1,used记录哈希表中已有节点的数量。
    - 除此之外就是dictht结构体的核心——table数组,是一个指针数组,每个指针元素都指向一个哈希表节点。
- 那么就到了第三层,最低层——哈希表节点,哈希表节点是dictEntry结构体:
    - dictEntry结构体有两个属性和一个指针,指针就是next指针,指向下一个dictEntry结构体,也就是通过next指针形成了单向链表解决哈希冲突。
    - dictEntry的两个属性分别是key和v,key就是键值对的键,是void*无类型指针,指向键对象；v就是键值对的值,是一个union集合,可选类型有void*无类型指针、uint64_t和int64_t
      <br>**以上这就是整个字典结构上的组成**。
 - 之后我再讲一下加入键值对的步骤,加入键值对就三步:
    - 首先是通过调用dictType中的函数计算键的hash值,通过MurmurHash2算法。
    - 第二步是将sizemask和哈希值进行按位与运算得出要插入的索引值。
    - 第三步就是通过计算出的索引值,找到当前允许键值对的哈希表的索引,把键值对插入到那个索引的单向链表的表头,就完毕了。
    - **最后再讲下Rehash**
    - 字典在不断扩充或者减少的时候需要进行rehash来调整哈希表结构。字典通过判断负载因子和服务器当前的运行情况来判断是否进行rehash。负载因子=正在使用的哈希表的used属性除以size属性。
        - 当服务器没有进行BGSAVE命令或者BGREWRITER命令的时候,如果负载因子>=1就执行rehash扩展操作。
        - 当服务器正在执行BGSAVE命令或者BGREWRITER命令的时候,如果负载因子>=5就执行rehash扩展操作。
        - 当负载因子<=0.1的时候,程序会自动开始对哈希表进行rehash收缩操作
- rehash的步骤不是一次性的,而是分多次、渐进式地进行,rehash的步骤有四步:
    - 第一步是为哈希表1分配足够的空间：如果执行的是扩展操作,那么哈希表1的空间大小为第一个>=哈希表0的used属性的两倍的一个二次方幂（这里可以举例）;如果执行的收缩操作,那么哈希表1的代销是第一个>=哈希表0的used属性的二次方幂。
    - 第二步是将字典的rehashidx设置为0,表示rehash工作开始,而rehashidx的值就是代表之后转移的时候应该存放的目标索引是多少,从0开始。
    - 第三步就是转移,将哈希表0中的键值对转移到哈希表1中,这个步骤不是一次性的,而是渐进的,每次对字典进行添加、删除、查找、更新的操作都会顺便从哈希表0中转移一个哈希表节点到哈希表1中,转移的时候需要对键值对进行重新散列操作（也就是重新计算索引值和hash值）。所以每次操作都会使rehashidx的值加1。
    - 第四步是当哈希表0的键值对都转移到了哈希表1的时候,字典将rehashidx的值设置为-1,再将哈希表1设置为哈希表0,哈希表0设置为哈希表1,将新的哈希表1清空为空表,rehash操作完成。
    </details>
<details><summary>4.跳跃表</summary>

- 跳跃表的核心是一个个串联起来的跳跃表节点,通过跳跃表节点来存储数据,每个跳跃表节点存储指向数据的指针,这里的数据通常是字符串对象。
- 跳跃表的特点是有序以及能快速访问查找某个节点。**有序**是因为每个跳跃表节点都有一个分值属性,跳跃表节点按照分值从小到大排序,当分值相同的时候按字符串对象的字典序从小到大排序；**快速访问**是因为每个跳跃表节点上都有许多层,层高是一个介于1到32之间的随机数,每个层都有一个指向其它节点的指针和跨度属性,通过这些层的指针不断向后跳跃查找从而实现快速访问,通过跨度计算某个节点的排名。通过跳跃表算法进行建层,它的查找复杂度是平均O(logN)、最坏O(N)的复杂度。
- 除此之外,跳跃表结构有同时指向表头节点和表尾节点的指针,而且每个跳跃表节点都有后退指针,所以也支持从后向前遍历,但后退只指向前面一位,不能跳跃。
- 另外返回跳跃表的节点个数是O(1),因为跳跃表有length属性记录跳跃表节点个数；还有一个level属性记录除了表头节点外层数最高的节点的层数。
- 注意跳跃表不仅仅是通过一个个跳跃表节点链接在一起的，外面还有一个zskiplist结构包装
<details><summary>跳跃表的层高是怎么决定的？</summary>

- 层高和节点存储的数据没有关系，是通过幂次定律随机生成一个介于1-32之间的随机数作为层高的，幂次定律就是比如第一层出现的概率是100%，那么第二层出现的概率就是50%，第三层就是25%，所以其实每个节点的层高都不会很高。
</details>
<details><summary>为什么Redis采用跳跃表而不是红黑树？</summary>

- 虽然红黑树和跳跃表的单点操作平均复杂度都是O(logn)，甚至跳跃表最坏的时候是O(n)大于红黑树，但是跳跃表有其它各方面原因优于红黑树
- **范围查找** 跳跃表比红黑树要更加优秀
    - 红黑树因为在查找到小值后，需要通过中序遍历找到小值到大值这一范围的数，经过的数的个数要根据树的具体结构而定，但一定是大于等于所需要查找的数的个数的。
    - 跳跃表在查找到小值之后只需要通过顺序遍历就能取出范围内的数，简单快速。
- 红黑树的插入和删除操作可能会引发子树的结构调整，逻辑复杂，而跳跃表只需要找到对应的结点相邻结点进行相关操作就行，简单快速。
- **内存占用**上，跳跃表比红黑树更灵活。因为跳跃表的层高是通过幂次定律随机生成的，所以跳跃表的实际每个节点存储的指针平均下来还不到2，是比红黑树每个结点固定是2要少的，跟节省内存，所以在大多数情况下跳跃表比红黑树占用内存更少
- 另外从算法实现难度上将跳跃表比红黑树更加容易实现
</details>
</details>
<details><summary>5.整数集合</summary>

- 整数集合是一个可以保存int16、int32、int64等整数值的有序集合,即没有重复元素。
- 整数集合内有一个contents数组和一个encoding属性,contents数组存储集合内的数据,数据类型有encoding决定,还有length属性能O(1)返回集合的大小
- 需要注意的是,整数集合有升级的操作,就是说它的contents数组内的数据的类型不是固定的,当新加入的数的类型比集合内所有的数据类型都要长时,就会进行升级,也就是说会先扩展数组的空间后将所有集合内的数据都提升至新加入的数据的类型,再把新数据加入到集合中。不过升级是不可逆的,即不能降级。升级这个操作是既兼顾了内存同时兼顾灵活性的一种做法。
</details>
<details><summary>6.压缩列表</summary>

- 压缩列表是由连续的内存块组成的顺序型数据结构,它的特点是节约内存。
- 压缩列表的组成有5部分:
    - (i)第一部分是zlbytes属性,记录整个压缩列表所占的内存字节数;
    - (2)第二部分是zltail属性,记录压缩列表表尾的节点距离列表的起始地址有多少字节,通过这个偏移量可以O(1)得到表尾节点的地址;
    - (3)第三部分是zllen属性,记录压缩列表的节点数;
    - (4)第四部分是各个节点,也是压缩列表的主要组成部分;
    - (5)第五部分是zlend,用来标记压缩列表的末端
- 而压缩列表的单个节点有三个属性
    - content属性记录节点的值
    - encoding属性记录节点值的数据类型和长度
    - 还有一个关键属性是**previous_entry_length**,记录前一个节点的长度,之所以记录这个是为了通过当前节点的地址和该属性计算出前一个节点的地址,从而实现**遍历**。这个属性的**大小**不是固定的,要么1字节要么5字节,如果前一个节点的长度小于254字节,那么这个属性就是1字节的,反之就是5字节的。
    - 所以由于其可变性,就涉及到一个**连锁更新**的问题,就是如果新加入或者删除某一个节点可能导致下一个节点的previous_entry_length属性的大小改变从而导致下一个节点从小于254字节变成了大于254字节,从而导致再下一个节点大小改变,这就是连锁更新。所以最坏的情况下连锁更新会导致**N次空间重分配**操作,而每次空间重分配的最坏复杂度是O（N）,所以连锁更新的最坏复杂度是O（N²）,但实际上发生的几率极低,平均下来压缩列表的操作的复杂度是O(N)的
    </details>

### 对象和数据结构

<details><summary>1.Redis的对象的结构</summary>

- Redis中的对象都是一个redisObject结构体
- 这个结构体中的type属性记录了对象的类型
- encoding属性记录了对象的所使用的编码
- lru属性记录对象最后一次被访问的时间,通过当前时间减去lru的时间得到键的空转时长,如果服务器开启了maxmemory功能的话,空转时长较长的键就会优先被删除,节约了内存。
- 还有refcount属性用于引用计数
- ptr指针,指向对象使用的数据结构。
- 通过refcount和ptr指针实现了对象的引用计数、内存共享和内存回收。原理就是新建一个对象的时候初始化refcount为1,之后每被共享或者被使用一次,refcount就会加一,不再被共享的时候就减一,如果为0就会执行内存回收。
</details>
<details><summary>2.Redis对象和数据结构的联系</summary>

- 首先Redis由5种对象,然后数据结构严格来说有8种（还有一种说法是忽略了底层数据结构,把对象当成数据结构的,所以会认为Redis有5种数据结构）
- 5种对象分别是字符串对象、列表对象、哈希对象、集合对象、有序集合对象；
    - 8种数据结构几乎每种数据结构都对应了一个编码,不过有一个例外,skiplist编码同时使用了跳跃表和字典作为底层数据结构,这些编码前面都有前缀Redis_coding_。
    - 8种数据结构分别是整数(编码:INT)、embstr编码的字符串(编码:EMBSTR)、简单字符串(编码:RAW)、字典(编码:HT，也就是hashtable的缩写)、双端链表(编码:LINKEDLIST)、压缩列表(编码:ZIPLIST)、整数集合(编码:INTSET)、跳跃表(编码:SKIPLIST,不过这个编码还得用到字典,所以这个编码要用到两个数据结构)。
- 5种对象和数据结构的关系更主要体现在5种对象所使用的编码上。
    - 字符串对象可以使用三种编码:INT、EMBSTR、RAW（有三种选择,但每个对象只使用其中一个编码）;
    - 其他对象都可以使用两种编码,列表对象可以使用ZIPLIST或者LINKEDLIST;
    - 哈希对象使用ZIPLIST或者HT;
    - 集合对象使用INTSET或者HT;
    - 有序集合对象使用ZIPLIST或者SKIPLIST。
    </details>
<details><summary>3.Redis五种对象使用不同编码的场景</summary>

- 字符串对象
    - 如果保存的数据可以用long类型表示,就用int编码,数据结构就是int。
    - 如果保存的是<=39字节的字符串,就用embstr编码。
    - 否则就是RAW编码。
    - 需要注意的是,embstr编码的情况下对象是只读的,如果进行了修改,就会改为用RAW编码,RAW和int会根据数据的类型进行互相转换编码。
- 列表对象
    - 当列表对象保存的所有字符串元素的长度都<64字节且元素个数<512时,就会采用ziplist编码也就是压缩列表作为底层数据结构。
    - 否则就是用linkedlist编码,用双端链表作为底层数据结构。
- 哈希对象
    - 当哈希对象保存的键值对的键和值的字符串长度都<64且键值对数量<512时,就会采用ziplist编码。
    - 否则用hashtable编码,就是采用哈希表作为底层数据结构。
- 集合对象
    - 当集合对象保存的元素都是整数值且数量<=512个时,就会采用intset编码,也就是采用整数集合作为底层数据结构。
    - 否则采用HT编码。
- 有序集合对象
    - 当有序集合保存的元素长度都<64字节且数量<128个时,采用ziplist编码。
    - 否则使用skiplist编码,也就是同时采用字典和跳跃表作为底层数据结构。
    </details>


### 单机数据库

<details><summary>1.Redis中键的生命周期你知道吗,键是分开存储的吗,键过期后是怎么被检测的？</summary>

- 首先Redis在添加一个新的键值对的时候,实际上是将这键值对添加到键空间字典中。Redis是一个键值对数据库服务器,每个服务器都是一个redisDb结构体,这个结构体中的dict字典保存了数据库所有的键值对,所以这个字典被称为键空间。对Redis中的键进行修改或者删除,也都是到这个键空间中找到这个键然后做相应的操作。
- 与键空间相对的,Redis中还有一个字典,expires字典,被称为过期字典。这个字典中记录了所有键的过期时间,过期字典的键是一个指针,指向数据库中的对象,值记录了这个对象的过期时间。我们可以通过EXPIRE、PEXPIRE、EXPIREAT、PEXPIREAT命令来设置键的过期时间,通过TTL或者PTTL命令来查看键的剩余生存时间。
- Redis中检测一个键过期有两步：第一步到过期字典中查找这个键,如果存在的话取出它的过期时间；第二步检查当前UNIX时间戳是否大于它的过期时间,如果是就可以判断这个键过期了。
</details>
<details><summary>2.Redis中过期键的删除策略你知道吗？</summary>

- Redis中的过期键的删除是通过惰性删除和定期删除两种策略配合使用的。各有优缺点（自己展开）
- 我再分别讲一下这两种策略是怎么实现的：首先是惰性删除策略,这个策略主要通过expireIFNeeded函数实现的。Redis中每个读写数据库的命令在执行前都会调用expireIFNeeded函数,当然事先会判断这个键是否存在,如果不存在的话,就直接返回空回复了,否则就会调用这个函数。如果操作键已经过期了,这个函数就会将这个键从键空间中删除,否则就没有动作。
- 然后是定期删除策略：这个策略主要通过activeExpireCycle函数实现
    - 每当Redis服务器的周期性函数serverCron函数执行的时候,activeExpireCycle函数就会被调用
    - 每次调用都会从一定数量的数据库中取出一定数量的随机键进行检查,并删除其中的过期键。
    - 每次调用结束都会记录这次检查到哪了,下一次调用会接着上一次调用的进度接着检查,这样保证Redis中每个数据库中的所有键都会被检查一遍,循环往复。
    </details>
<h3>持久化</h3>
<details><summary>1.RDB持久化是什么,怎么实现的</summary>

- RDB持久化就是通过RDB文件来保存和还原Redis服务器中所有数据库的键值对数据的一种方式。
- 有两个命令能生成RDB文件,一个是SAVE命令,另一个是BGSAVE命令：
    - SAVE命令会阻塞Redis服务器进程,而BGSAVE命令则是通过调用一个子进程去创建RDB文件,所以不会阻塞服务器进程；
    - 这两个命令的用法也不同,SAVE是主动调用的,BGSAVE通常是Redis自动运行的。
- BGSAVE命令通常需要通过ServerCron函数调用
    - ServerCron就是Redis周期性运行函数,默认每隔100毫秒就会运行一次
    - 每次运行的时候就会检查save选项所设置的保存条件是否满足,如果满足就会才会执行BGSAVE命令。
    - 这里的save选项是多个条件,只要满足其中之一就会执行BGSAVE命令,默认是三个条件：900秒1次、300秒10次和60秒10000次,这个意思就是如果每隔900秒数据库如果进行了1次修改,就会保存,等等。
    - 这个信息的获取通过Redis服务器维护的dirty属性和lastsave属性
        - dirty属性就是距离上一次执行SAVE或者BGSAVE,已经发生了多少次修改,所以每次执行SAVE或者BGSAVE,dirty都会清零；
        - lastsave记录最后一次执行SAVE或者BGSAVE的时间,是一个UNIX时间戳。
- 在BGSAVE调用子进程期间,服务器仍然可以处理客户端的命令请求,但是对SAVE、BGSAVE、BGREWRITEAOF三个命令的处理和平时不一样。
    - 在这时候,SAVE和BGSAVE命令会被拒绝,而BGREWRITEAOF命令会被延迟到BGSAVE子进程执行完毕后再执行
    - 不过反过来的话,如果现在在运行BGREWRITEAOF,客户端的BGSAVE命令会被拒绝,这样表明AOF持久化的优先级是高于RDB持久化的。
- 然后是关于载入RDB文件。Redis服务器没有专门用于载入RDB文件的命令,只要在Redis启动的时候自动检测到RDB文件的存在就会自动载入RDB文件来恢复数据库状态,也只有在Redis服务器启动的时候会载入RDB文件,载入的时候服务器会处于阻塞状态,直到载入完毕。不过通过RDB文件来恢复数据库状态只有在服务器的AOF持久化关闭的时候才会进行,如果服务器开启了AOF持久化功能,那么会优先使用AOF持久化。
</details>
<details><summary>2.AOF持久化是什么,怎么实现的</summary>

- AOF持久化就是通过AOF文件对数据库进行保存和恢复。而AOF文件保存了所有修改数据库的写命令请求,恢复数据库也通过模拟客户端写命令来恢复数据库状态的,AOF文件中的所有命令都是以Redis命令请求协议的格式保存的。
- AOF持久化的实现通过命令追加、文件写入和同步来实现：
    - **命令追加**就是,当服务器执行完一个写命令后,就会以协议的格式将被执行的写命令追加到服务器的aof_buf缓冲区的末尾；
    - 而文件的**写入和同步**通过调用一个函数,**这个函数叫flushAppendOnlyFile**,名字很长。
        - 首先Redis的服务器进程是一个事件循环,事件循环内有文件事件和时间事件,文件事件是负责接受客户端命令请求以及向客户端发送命令请求的；而时间事件就是执行像serverCron这样定时运行的函数的。
        - 而flushAppendOnlyFile这个函数（我后面就简称flush函数把）是在每次事件循环结束之前要调用的,也就是等待文件事件和时间事件结束后才会调用这个函数。
        - 然后在这个函数内会**根据服务器配置的appendfsync**选项的值来决定不同的写入同步行为：
            - 首先不管appendfsync属性的值是什么,每次调用flush都会将aof_buf缓冲区内的所有内容写入到AOF文件中；
            - 然后如果appendfsync的值是always的话,那flush..那个函数每次调用都会将aof_buf缓冲区的所有内容同步到AOF文件；
            - 如果是appendfsync的值是everysec的话,只有当上一次同步AOF文件的时间距离现在超过1s才会对AOF进行同步,这个同步操作是有一个线程专门负责进行的；
            - 如果appendfsync属性的值是no的话,那么flush函数不会对AOF进行同步,什么时候同步只能由操作系统来决定的。
            - 这三种属性的效率依次提高,但安全性依次下降。
- 然后我讲一下AOF文件的载入和数据还原：通过读入并执行AOF文件中的写命令就能还原服务器状态
    - 所以第一步是**创建一个不带网络连接的伪客户端**这是因为Redis的写命令必须通过客户端执行。
    - 第二步是解析AOF文件读取出一条写命令
    - 第三步是使用伪客户端执行写命令
    - 第四步就是重复二、三步直到所有命令执行完毕。这就是AOF载入和数据还原。
- 不过如果仅仅单纯记录写命令的话,会导致AOF文件体积过大,所有Redis提供了AOF文件重写功能,AOF文件重写就是创建一个新的AOF文件来替代原有的AOF文件,而新的AOF文件命令更精简,体积更小,更节省空间。不过AOF重写不是通过分析原有的AOF文件进行精简的,而是通过读取现有的服务器的状态,对现有的键值对进行分析,转换成精简的写命令来创建新的AOF文件的。而AOF重写的调用的话通常是Redis自行触发的,不过我们也可以通过调用BGREWRITEAOF命令来进行AOF重写。
- 然后我再说一下AOF重写的方式：
    - Redis不希望AOF重写会长时间地阻塞服务器进程,所以将AOF重写放到一个子进程中进行。
    - 不过这样的话因为没有阻塞服务器进程,所以在AOF重写的期间,服务器还会继续添加写命令,为了保证AOF重写完毕时保存的状态就是那时候的服务器状态
    - AOF重写维护了一个AOF重写缓冲区。所以在AOF重写期间,客户端执行的每个写命令都会同时追加到AOF缓冲区和AOF重写缓冲区。
    - 而在重写期间,服务器同时做三个工作:
        - 一边处理客户端发来的写命令请求
        - 一边将这个请求写入AOF_buf缓冲区和AOF重写缓冲区中
        - 一边进行对现有的数据库状态执行AOF重写。
    - 等子进程重写完毕后,子进程就会发出一个信号,父进程接收后就会调用信号处理函数执行重写最后的工作：这时候才会阻塞服务器进程,将AOF重写缓冲区的指令写入到新的AOF文件中
    - 等全部写完再将新的AOF文件改名覆盖现有的AOF文件,重写工作才算完成。所以真正阻塞的时间只有写入AOF缓冲区的指令的时间,效率很高。
    </details>
