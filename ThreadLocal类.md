# ThreadLocal类

## 应用背景

​	并发编程中多个线程同时访问和修改变量时出现的线程安全问题，锁机制可能会带来性能上的损失，因为线程之间需要竞争锁，而且在等待锁的过程中会阻塞 线程的执行。

​	使用ThreadLocal的好处在于它避免了线程之间的竞争和阻塞，提高了并发性能。同时，它也简化了编程模型，因为开发者不需要显式地使用锁来保护共享变量的访问。

​	需要注意的是，ThreadLocal并不适用于所有场景。它主要适用于**每个线程需要独立保存自己的数据副本的情况**（可以隔离并保存每个线程的数据）。如果多个线程之间需要共享数据并进行协作，那么使用锁或其他同步机制可能更为合适。此外，在使用ThreadLocal时也需要注意内存泄漏和数据污染的问题，需要正确地管理和清理线程本地存储的数据。

## 核心特性

1. **线程隔离**：每个线程对 `ThreadLocal` 变量的修改对其他线程是不可见的。
2. **无继承性**：子线程不能访问父线程的 `ThreadLocal` 变量，除非子线程中有显式的设置或复制操作。
3. **避免同步**：由于每个线程都有自己的变量副本，因此不需要同步就可以保证线程安全。

## 使用场景

​	**数据库连接：**在多线程应用中，每个线程可能需要自己的数据库连接。使用 ThreadLocal 可以为每个线程保存其自己的连接。
​	**会话管理：**在 Web 应用中，每个用户的会话数据可以使用 ThreadLocal 存储，从而确保同一用户的多个请求在同一个线程中处理时能够访问到正确的会话数据。
​	**线程内上下文传递**：有时需要在同一个线程的不同方法之间传递一些上下文信息，而不希望使用全局变量或参数传递。这时可以使用 ThreadLocal。

## 注意事项

​	**内存泄漏**：如果线程不再需要使用该变量，但忘记调用 remove() 方法来清理，那么由于 ThreadLocalMap 中的 Entry 的 key 是对 Thread 的弱引用，所以 Thread 被回收后，Entry 的 key 会被置为 null，但 value 不会被回收，从而导致内存泄漏。因此，使用完 ThreadLocal 后，最好调用 remove() 方法来清理。
​	**线程池中的使用**：在线程池中，线程可能会被复用。如果线程之前设置过 ThreadLocal 变量，但在使用后没有清理，那么下一个任务可能会读取到上一个任务设置的值。因此，在线程池中使用 ThreadLocal 时需要特别小心。
​	**初始化问题**：如果不重写 initialValue() 方法，并且在使用前没有调用 set() 方法设置值，那么 get() 方法将返回 null。为了避免这种情况，可以重写 initialValue() 方法来提供一个默认值。
​	**不适用于全局共享状态**：虽然 ThreadLocal 可以在多个线程之间隔离数据，但它不适用于需要在多个线程之间共享和修改的全局状态。对于这种情况，应该使用其他同步机制（如锁或原子变量）。

## 问题避免措施

1.在使用完ThreadLocal后，及时调用remove()方法清理资源。
2.使用静态内部类来持有ThreadLocal对象，以确保它不会被提前回收。
3.尽量避免在长时间运行的线程中使用ThreadLocal。
4.使用Java 8引入的InheritableThreadLocal来替代ThreadLocal，它可以在子线程中自动继承父线程的线程局部变量值，从而避免在创建新线程时重复设置值的问题。但是同样需要注意及时清理资源以避免内存泄漏。




​	