# JVM

## class字节码

class文件本质上是一个以**8位字节**为基础单位的二进制流。字节码文件的结构是由JVM固定的。

#### java字节码文件包括哪些类型的数据

- 魔数和文件版本
- 常量池（资源仓库，占用最大的数据项目
- 访问标志（是类还是接口？访问类型？是否final
- 类索引、父类索引、接口索引（描述类的继承关系
- 字段表属性（描述接口或类中声明的变量的作用域、类型、可变性final？、是否静态等
- 方法表属性（描述声明的方法的类型、作用域等
- 属性表属性（描述某些场景专有的信息，比如字段表中特殊的属性、方法表中特殊的属性

## 字节码增强技术（了解）

​	对现有字节码进行修改或者动态生成全新字节码文件的技术。字节码增强技术相当于是一把**打开运行时JVM的钥匙**，利用它可以动态地对运行中的程序做修改，也可以跟踪JVM运行中程序的状态。此外，我们平时使用的动态代理、AOP也与字节码增强密切相关，它们实质上还是利用各种手段生成符合规范的字节码文件。综上所述，掌握字节码增强后可以**高效地定位并快速修复一些棘手的问题**（如线上性能问题、方法出现不可控的出入参需要紧急加日志等问题），也可以在开发中减少冗余代码，大大提高开发效率。

## 类生命周期

![image-20240321112653515](C:\Users\灯\AppData\Roaming\Typora\typora-user-images\image-20240321112653515.png)

​	在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则**顺序不一定**，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而**不是按顺序进行或完成**，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

### 类加载

- 通过一个类的全限定名来获取其定义的二进制**字节流**。
- 将这个字节流所代表的静态存储结构转化为**方法区的运行时数据结构**。
- 在Java**堆中**生成一个代表这个类的**java.lang.Class对象**，作为对方法区中这些数据的访问入口。

###### **类加载有几种方式:**

1. 命令行启动应用时候由JVM初始化加载
2. 通过Class.forName()方法动态加载
3. 通过ClassLoader.loadClass()方法动态加载

###### **Class.forName和ClassLoader.loadClass的区别：**

Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；

ClassLoader.loadClass(): 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块

### 类加载机制

- 全盘负责：负责加载的类加载器也负责载入依赖和引用的其他类
- 父类委托：优先让父类加载器尝试加载
- 缓存机制：保证所有加载过的Class都会被缓存
- 双亲委派机制：所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。（防止内存中出现多份相同的字节码

###### **双亲委派机制过程？**

1. 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；
4. 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

### 连接

验证包括四个部分：文件格式验证、元数据验证、字节码验证、符号引用验证。（验证是非必须可关闭的）

准备阶段正式为**类变量**分配内存并设置类变量**初始值**，**这些内存分配在方法区中**。对于该阶段有以下几点需要注意:

- 这时候进行内存分配的仅包括类变量(`static`)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

- 这里所设置的初始值通常情况下是数据类型默认的零值(如`0`、`0L`、`null`、`false`等)，而不是被在Java代码中被显式地赋予的值。

  假设一个类变量的定义为: `public static int value = 3`；那么变量value在准备阶段过后的初始值为`0`，而不是`3`，因为这时候尚未开始执行任何Java方法，而把value赋值为3的`put static`指令是在程序编译后，存放于类构造器`<clinit>()`方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

解析阶段虚拟机将常量池内的符号引用替换为直接引用，**符号引用**就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 初始化

初始化，为类的静态变量赋予正确的初始值。只有当对类的主动使用的时候才会导致类的初始化

##### 卸载

###### **Java虚拟机将结束生命周期的几种情况**

- 执行了System.exit()方法
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止

## JVM内存结构（运行时数据区）

​	程序计数器、本地方法栈、栈属于**线程之间私有数据区**；堆和方法区属于所有**线程共享数据区**（线程共享的还有**堆外内存**，如Java7的永久代码或JDK8的元空间、代码缓存）。

> **栈是运行时的单位，而堆是存储的单位**。
>
> 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。

### 程序计数器（Program Counter Register）

​	**JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟**。程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的**行号指示器**，用来存储指向下一条指令的地址。**是唯一一个在 JVM 规范中没有规定任何 `OutOfMemoryError` 情况的区域**。

###### 为什么需要计数？为什么会被设置成线程私有的？

​	因为CPU需要不停的切换各个线程，切换到一个线程后，需要知道从哪开始执行。所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。

### 虚拟机栈

每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的**栈帧(Stack Frame）**，对应着一次次 **Java 方法**调用，是线程私有的，生命周期和线程一致。不同线程中所包含的栈帧是不允许存在相互引用的。

主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着**入栈**（进栈/压栈），方法执行结束**出栈**（先进后出）。

**栈不存在垃圾回收问题**

固定大小栈会出现StackOverflowError异常，可动态扩展的栈会出现OutofMemoryError异常

##### 栈顶缓存

由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，**将栈顶元素全部缓存在物理 CPU 的寄存器中**，以此降低对内存的读/写次数，提升执行引擎的执行效率

##### 栈帧的内部结构

![0082zybply1gc8tjehg8bj318m0lbtbu](D:\学习记录\pic\0082zybply1gc8tjehg8bj318m0lbtbu.jpg)

1. ==局部变量表==：**主要用于存储方法参数和定义在方法体内的局部变量**，局部变量表中的变量只在当前方法调用中有效。

   - 局部变量表最基本的存储单元是 Slot（变量槽），32 位以内的类型占用一个 Slot。
   - 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**按照顺序被复制**到局部变量表中的每一个 Slot 上。
   - **如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可**。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）
   - 栈帧中的局部变量表中的槽位是可以重用的**
   - 如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 **index 为 0 的 Slot 处**，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为this 变量不存在于当前方法的局部变量表中）
   - **局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收**

2. ==操作数栈/表达式栈==：**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**

   - 操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，**此时这个方法的操作数栈是空的**。每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 `max_stack` 数据项中。

   - 栈中的任何一个元素都可以是任意的 Java 数据类型，32bit 的类型占用一个栈单位深度。

   - 操作数栈**并非采用访问索引的方式**来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问

   - **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新 PC 寄存器中下一条需要执行的字节码指令

   - 说**Java虚拟机的解释引擎是基于栈的执行引擎**，其中的栈指的就是操作数栈

3. ==动态链接==：指向运行时常量池的方法引用。

   ​	在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为**符号引用**（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**。动静态的区别是被调用的方法在编译器是否被确定下来。

   ​	将符号引用转换为调用方法的直接引用与方法的**绑定机制**（早期绑定、晚期绑定）有关

4. ==方法返回地址==：用来存放调用该方法的 PC 寄存器的值。

   无论通过**正常完成出口**还是通过**异常完成出口**退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。

5. ==附加信息==

   与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。

### 本地方法栈

本地方法接口（ Native Method ）就是一个 Java 调用非 Java 代码的接口。

##### 为什么要使用本地方法（Native Method）?

有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，需要本地方法

- 与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。
- 与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。
- Sun's Java：Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。JRE大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 `java.lang.Thread` 的 `setPriority()` 的方法是用Java 实现的，但它实现调用的是该类的本地方法 `setPrioruty()`，该方法是C实现的，并被植入 JVM 内部。

**Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用**

- 本地方法是使用 C 语言实现的

- 它的具体做法是 `Native Method Stack` 中登记 native 方法，在 `Execution Engine` 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。

- 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存。

- 并不是所有 JVM 都支持本地方法。

- 在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一

### 堆内存

​	Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是**存放对象实例**，几乎所有的对象实例以及数据都在这里分配内存。

​	为了进行高效的垃圾回收，虚拟机把堆内存**逻辑上**划分成三块区域（==分代的唯一理由就是优化 GC 性能==）：

- 新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代
- 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
- 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存

​	Java 堆可以是处于物理上不连续的内存空间中，堆的大小在 JVM 启动的时候就确定了，通过 `-Xmx` 和 `-Xms` 来设定

![00831rSTly1gdbr7ek6pfj30ci0560t4](D:\学习记录\pic\00831rSTly1gdbr7ek6pfj30ci0560t4.jpg)

##### 对象的分配过程和生命周期

- 当创建一个对象时，对象会被优先分配到新生代的 Eden 区 ，此区有大小限制，此时 JVM 会给对象定义一个**对象年轻计数器**（`-XX:MaxTenuringThreshold`）

- 当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC），将不再被其他对象所引用的对象进行销毁，再加载新的对象。

- JVM 会把存活的对象转移到 Survivor 0中，并且对象年龄 +1
- 对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1，默认15次回收标记后会进入养老区
- 当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理。若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 **OOM 异常**。

##### 垃圾回收GC

分为**部分收集**：新生代收集（Minor GC/Young GC）、老年代收集（Major GC/Old GC）、混合收集（Mixed GC）和**整堆收集**（Full GC）

##### 什么是TLAB（thread local allocation buffer）

从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为**每个线程分配了一个私有缓存区域**，它包含在 Eden 空间内。

多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为**快速分配策略**。

##### 为什么要有TLAB

- 堆区是线程共享的，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度

尽管**不是所有的对象实例都能够在 TLAB 中成功分配内存**，但 JVM 确实是将 TLAB 作为内存分配的首选。

默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 `-XX:TLABWasteTargetPercent` 设置 TLAB 空间所占用 Eden 空间的百分比大小。

一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。

##### 逃逸分析（了解）

当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。

使用逃逸分析，编译器可以对代码做**优化**：

- **栈上分配**：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递。
- **同步省略**（锁消除）：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步
- **分离对象或标量替换**：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器

**上述优化的目的**： JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM **通过逃逸分析确定该对象不会被外部访问**。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。

### 方法区

​	**方法区（method area）**只是 JVM 规范中定义的一个概念，用于存储**类型信息、常量池、静态变量、JIT编译后的代码**等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代（PermGen）是 Hots pot虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。

运行时常量池（Runtime Constant Pool）是方法区的一部分。JVM 关闭后方法区即被释放

对于方法区，**Java8 之后的变化：**

- 移除了永久代（PermGen），替换为元空间（Metaspace）；
- 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；
- 永久代中的 interned Strings 和 class static variables 转移到了 Java heap；
- 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）

**类型信息**

每个加载的类型（类、接口、枚举、注解），存储其类型信息：

- 完整有效名称（全名 = 包名 **. **类名）
- 直接父类的完整有效名称
- 类型的修饰符（public，abstract，final的某个子集）
- 类型直接接口的一个有序列表

###### 域（Field）信息

- JVM 必须在方法区中保存**类型的所有域**的相关信息以及域的声明顺序
- 域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）

###### 方法（Method）信息

VM 必须保存所有方法的

- 方法名称
- 方法的返回类型
- 方法参数的数量和类型
- 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）
- 方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）
- 异常表（abstract 和 native 方法除外） 
  - 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

#### **栈、堆、方法区的交互关系**（要能讲得出这个过程，比如实例被创建、被调用过程）

```
public static void main(String[] args) throws Exception {
        Function jububianliang = new Function<T,R>() {//这里取名jububianliang只是为了方便区分
        //等式左边的是局部变量，一般取名方式是全小写的实例名
        //jububianliang是引用变量，引用Function实例，存放在栈中
        //new Function()的实例放在堆中
            jububianliang.ff2();//调用ff2方法
        };
        //JVM将继续执行后续指令，在堆区里继续创建另一个Function类的实例，然后执行out方法。
        //当JVM执行function.out2()方法时，JVM根据局部变量function持有的引用，定位到堆中的Function类的实例，再根据Function类的实例持有的引用，定位到方法区中Function类的类型信息（包括①类，②静态变量，③静态方法，④常量和⑤成员方法），从而获取out2()成员方法的字节码，将out2()方法进行压栈操作，当执行out2()方法中的out1()方法时就涉及到动态链接。
    }

    public class Function(){
        public void ff1(){
            System.out.println("ff1是Function内的一个方法");
        }
        public void ff2(){
            ff1();//方法2内调用方法1，就会产生动态链接
            System.out.println("ff2是Function内的另一个方法");
        }
    }
```

#### Function function = new Function<T,R>(){}这一步实际完成的工作是什么？

1. 加载Function类，把Function类的相关信息存放在了方法区中。
2. JVM在堆中为一个新的**Function类的实例**分配内存，这个**Function类的实例**持有着**指向方法区**中Function类的类型信息的**地址**
3. 位于“=”前的function 是一个局部变量，这个局部变量会被JVM添加到**执行main()方法的主线程的Java方法调用栈**中。（因为它是由main()方法定义的。“=”将把这个变量指向堆区中的Function实例，也就是说，function 这个局部变量持有指向Function类的实例的内存地址。（==用这个局部变量装指向实例的内存地址==）
4. 调用后续方法时，从局部变量➡实例➡实例的引用（方法区的类型信息）➡成员方法的字节码

#### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。

java编译后产生的字节码存到**常量池**，常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。

在加载类和结构到虚拟机后，就会创建对应的运行时常量池

常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，**这部分内容将在类加载后存放到方法区的运行时常量池中**

JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。

运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括**到运行期解析后才能够获得的方法或字段引用**。

运行时常量池，相对于 Class 文件常量池的另一个重要特征是：**动态性**，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 `intern()` 方法就是这样的

### JMM（java内存模型 memory model）



## 针对面试的JVM

#### 了解内存溢出问题吗？怎么产生的？怎么排除？和内存泄漏的区别？

​	**内存溢出（Out Of Memory，简称 OOM）是指无用对象（不再使用的对象）持续占有内存，或无用对象的内存得不到及时释放，从而造成的内存空间浪费的行为就称之为内存泄露。**内存溢出包括堆溢出和元数据溢出，常见原因比如：启动参数初始值设置得太小，代码中存在死循环或循环产生过多重复的对象实体，集合类中引用的对象使用后未清空导致无法回收

​	解决方式：通过修改启动参数增加内存、检查错误日志、对代码进行走查和分析，找出可能发生内存溢出的位置





