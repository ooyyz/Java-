# 操作系统
------
* 进程和线程
    * [进程和线程有什么区别？](#进程和线程有什么区别)
    * [进程有哪些组成部分？](#进程有哪些组成部分)
    * [进程的上下文及组成部分？](#进程的上下文及组成部分)
    * [哪些东西应该划归到资源管理?](#哪些东西应该划归到资源管理)
    * [同一进程中的线程可以共享哪些数据？](#同一进程中的线程可以共享哪些数据)
    * [线程独占哪些资源？](#线程独占哪些资源)
    * [进程间通信有哪些方式？](#进程间通信有哪些方式)
    * [进程有哪几种状态？](#进程有哪几种状态)
    * [进程调度策略有哪些？](#进程调度策略有哪些)
    * [什么是僵尸进程？](#什么是僵尸进程)
    * [线程同步有哪些方式？](#线程同步有哪些方式)
    * [什么是协程？](#什么是协程)
    * [协程与线程进行比较？](#协程与线程进行比较)
    * [什么是用户态和内核态？](#什么是用户态和内核态)
    * [如何从用户态切换到内核态？](#如何从用户态切换到内核态)
* 死锁
    * [什么是死锁？](#什么是死锁)
    * [死锁产生的必要条件？](#死锁产生的必要条件)
    * [死锁有哪些处理方法？](#死锁有哪些处理方法)
* 内存管理
    * [内存管理？](#内存管理)
    * [什么是分页和分段,有什么区别？](#什么是分页和分段以及它们的区别)
    * [什么是虚拟内存？](#什么是虚拟内存)
    * [有哪些页面置换算法？](#有哪些页面置换算法)
    * [如何进行地址空间到物理内存的映射？](#如何进行地址空间到物理内存的映射)
* 文件系统与I/O
    * [Linux文件系统几种权限？](#Linux文件系统几种权限)
    * [文件系统和磁盘有什么关系？](#文件系统和磁盘有什么关系)
    * [文件系统有哪些结构？](#文件系统有哪些结构)
    * [什么是虚拟文件系统？](#什么是虚拟文件系统)
    * [5种IO（阻塞/非阻塞/异步/信息驱动型/多路复用）？](#5种IO模型)
    * [IO调度算法有哪些？](#IO调度算法有哪些)
    * [什么是DMA技术？](#什么是DMA技术)
    * [传统的I/O方式需要几次拷贝（才能把磁盘上的数据输出到网络端口）及具体过程？](#传统的I/O方式需要几次拷贝及具体过程)
    * [什么是零拷贝技术？](#什么是零拷贝技术)
    * [磁盘调度](#磁盘调度)
* 系统与系统调用
    * [CPU由哪几部分组成？](#CPU由哪几部分组成)
    * [32位操作系统和64位操作系统的区别?](#32位操作系统和64位操作系统的区别)
    * [什么是系统调用？](#什么是系统调用)
    * [系统调用和一般调用的区别？](#系统调用和一般调用的区别)
    * [系统调用有哪几种？](#系统调用有哪几种)
    * [为什么要用系统调用，有什么好处、意义？](#系统调用的意义)
    * [系统调用是怎么实现的或者说过程？](#系统调用是怎么实现的或者说过程)
* 其它
    * [大小端模式](#大小端模式) 
------

### 进程和线程有什么区别？
- 进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；
- 线程依赖于进程而存在，一个进程至少有一个线程；
- 进程有自己的独立地址空间，线程共享所属进程的地址空间；
- 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；
- 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
- 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；
- 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮
##### 进程有哪些组成部分
- 进程主要由**进程控制块**和相应的**地址空间**（或者说程序段和数据段）组成
- 进程控制块主要包含：
    - 进程标识符(即进程ID)
    - 进程的当前状态
    - 相应的进程控制信息
- 地址空间则可分为三部分：
    - 程序段：存放相应的程序代码
    - 用户数据段：存放相应的程序处理数据
    - 系统数据段：存放相应的程序运行环境。
##### 进程的上下文及组成部分
- 可执行程序代码，是进程的重要组成部分。进程上下文实际上是进程执行活动全过程的静态描述。
- 用户级上下文：正文、数据、用户堆栈以及共享存储区；
- 寄存器上下文：通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
- 系统级上下文：进程控制块(task_struct)、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。
##### 哪些东西应该划归到资源管理
- 比如进程间调度、IO调度、磁盘调度等，包括死锁问题都属于资源管理
##### 同一进程中的线程可以共享哪些数据？
<details>
<summary>展开</summary>

- 进程代码段
- 进程的公有数据（全局变量、静态变量...）
- 进程打开的文件描述符
- 进程的当前目录
- 信号处理器/信号处理函数：对收到的信号的处理方式
- 进程ID与进程组ID
</details>

##### 线程独占哪些资源？
<details>
<summary>展开</summary>

- 线程ID
- 一组寄存器的值
- 线程自身的栈（堆是共享的）
- 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；
- 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）
</details>

### 进程间通信有哪些方式

<details><summary>展开</summary>

1. 管道
- 管道分为匿名管道PIPE和命名管道FIFO
    - 匿名管道(Pipe)
    	- 匿名管道是**半双工**的，数据是**单向流动**的
    	- 比如说Linux中的'|'就是匿名管道，'|'的功能就是左边文件的输出是右边文件的输入。所以匿名管道并没有用什么东西保存，也就是说匿名管道**使用完就会销毁**。
    	- 需要注意的是匿名管道只能用于具有**亲缘关系**的进程
    	- 再说下匿名管道通信的**过程**：
    		1. 首先匿名管道的原型是一个int类型的pipe函数，通信成功返回0，失败返回-1。传入参数是一个fd数组，这个数组只有两个元素，fd[0]和fd[1]，一个是管道读端，另一个是管道写端。一开始父进程创建匿名管道，让两个文件描述符指向这管道的两端。
    		2. 然后父进程fork出子进程，子进程也有两个文件描述符指向这个管道。
    		3. 之后父进程再关闭fd[0]管道读端,子进程关闭fd[1]管道写端，因为管道是单向的，这样就使得数据从父进程写端流入，读端流出，完成进程间通信单向通信。如果要让数据从子进程流向父进程，就关闭的端口换一下，所以同一时刻一个管道只能完成单向的数据传输。
    - 命名管道(FIFO)
    	- 命名管道通过mkfifo命令创建，用一个自己命名的变量或者说文件存储，因为Linux下都视为文件，这个文件就是命名管道，有路径名与之关联。
    	- 命名管道的通信没有亲缘关系的限制，只要能访问命名管道文件的路径的进程就能跟本进程通信，所以命名管道没有亲缘限制
        - 另外因为它的读写数据的方式是先进先出FIFO，所以又把这种管道通信称为FIFO管道通信
- 管道类似于缓存，一个进程把数据放在缓存中，让另外一个进程取，单个管道是半双工，数据是单向流动的。
- 管道缺点是效率较低，不适合频繁地交换数据；优点是实现简单，自带同步互斥机制
2. 消息队列
    - 消息队列是消息的**链表**，放在内核中并且有标识符标识
    - 队列中的消息有特定的格式和优先级
    - 消息队列和命名管道一样可以支持两个不相关的进程通信,但是消息队列**能传递的信息更多**，而且是独立的。
    - 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除，生命周期是跟随内核的，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在,所以相比于管道，解决了必须等待进程来取数据的问题
    - 消息队列可以实现消息的随机查询, 消息不一定要以先进先出的次序读取,也可以按消息的类型读取
    - 消息队列的**优点**就是提到的数据独立于进程，能双向通信，允许多个进程写入读取数据。**缺点**有两个：一个是消息队列**不适合传输比较大的数据**，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限；另一个是消息队列通信中，存在用户态与内核态之间的**数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态。读数据的时候，会从内核态拷贝数据到用户态。
3. 共享内存
    - 共享内存解决了消息队列拷贝数据所消耗的时间。
    - 系统会给每个进程分配一个独立的虚拟空间，不同的虚拟内存映射到不同的物理内存中，所以即便A与B的虚拟地址是一样，但是他们访问的是不同的物理地址，对于数据的增删改查互不影响。 共享内存的机制，是两个进程各拿出一块虚拟空间，**映射到相同的物理内存中**。这样一个进程写入东西的时候，另一个进程马上就看到了，不需要来回拷贝，所以共享内存也是**最快**的通信方式。
    - 共享内存的优点是通信快，缺点是需要进行进程间同步，否则两个进程同时操作一块物理内存会出问题，所以共享内存经常和信号量一起使用，或者也可以使用互斥锁。
4. 信号量(Semaphore)：
    - 信号量是一个**整型计数器**不同于其它通信方式，它不存储通信数据，而是进程间同步的方式，用来控制多个进程对共享资源的访问，如果真的传递数据需要结合共享内存的方式。
    - 信号量是一种**锁机制**，用来防止某个进程访问共享资源的时候其它进程也访问这个资源，实现进程间同步
    - 程序对信号量的操作都是**原子**操作，信号量是基于操作系统的PV操作，**P操作**使得信号量-1然后再判断信号量是否小于零，如果小于0就先阻塞进程，再让进程进入到信号量的等待队列中，再进行进程调度；否则就让进程继续运行。**V操作**使信号量+1，然后判断信号量是否小于等于0，如果小于等于0，就从信号的等待队列释放一个进程，然后再返回原进程或者进行进程调度。P操作是在进入共享资源之前，V操作是离开共享资源，两个必须**成对**出现。
    - 最简单的信号量就是只能取0和1的变量，叫二值信号量也叫互斥信号量，因为这保证了同一时间只有一个进程在访问，保护了共享内存；如果能取多个整数的信号量被称为通用信号量，Linux下的信号量函数都是在通用的信号量数组上操作的。
5. 信号(Signal)
    - 信号传递的消息特别少，所以用信号进行通信仅用于通知接收进程某个事件发生
    - 信号的事件的来源主要是两个：一个是硬件来源，通过键盘输入；另一个是软件来源，比如输入kill命令
        - 如果是运行在shell终端的进程，可以通过键盘组合键的方式，给进程发信号：比如ctrl+C产生SIGINT信号，表示终止该进程；ctrl+Z产生SIGTSTP信号，表示停止该进程，但未结束。
        - 如果进程是在后台运行的，可以通过kill命令来给进程发信号，但需要提前知道进程的PID号
    - 信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程
    - 我们可以设置进程在收到信号后的反应：一个是不进行设置，让进程执行信号的默认操作；另一个是定义一个信号处理函数，进行捕捉信号做相应的处理；另外还可以忽略信号。
6. 套接字(Socket)
    - Socket利用三元组（ip地址，协议，端口）唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。
    - 如果是使用本地套接字的话，就是本机的两个进程通信
    - 如果是网络套接字的话，可以进行不同主机上的进程间通信，就是TCP字节流通信和UDP数据报通信，也就是网络编程，但网络编程我还没开始学，但是之前有实现过多线程客户端聊天室，是用本地局域网IP的，也是用Socket实现。
    - Socket通信是全双工的，同一时间可以双向通信
- 注：消息队列和管道基本上都是4次拷贝，而共享内存（mmap, shmget）只有两次。
- 4次：1-将用户空间的数据拷贝到内核中。2-内核将数据拷贝到内存中。3-从内存取出数据到内核。4-内核到用户空间.
- 2次： 1-用户空间到内存。 2-内存到用户空间。
</details>

##### 不同场合怎样选择合适的通信方式


##### 临界区的概念？
<details>
<summary>展开</summary>

各个进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段
</details>

##### 同步与互斥的概念？
<details>
<summary>展开</summary>

- 同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；
- 互斥：多个进程在同一时刻只有一个进程能进入临界区
</details>

##### 并发、并行、异步的区别？

<details>
<summary>展开</summary>

并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；

多线程：并发运行的一段代码。是实现异步的手段

并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的

异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事
</details>

### 进程有哪几种状态？

![Process State](_v_images/20191202090217863_1873.png)

- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行
- 运行态→阻塞态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。
- 阻塞态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。
- 运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。
- 就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态

### 进程调度策略有哪些？

1. **批处理系统**：

<details>
<summary>先来先服务 first-come first-serverd（FCFS）</summary>

按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）；

对短进程不利，对IO密集型进程不利。
</details>

<details>
<summary>最短作业优先 shortest job first（SJF）</summary>

按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；

对短进程提供好的响应时间，对长进程不利。
</details>

<details>
<summary>最短剩余时间优先 shortest remaining time next（SRTN）</summary>

按剩余运行时间的顺序进行调度。(最短作业优先的抢占式版本)。吞吐量高，开销可能较大，提供好的响应时间；

可能导致饥饿问题，对长进程不利。
</details>

<details>
<summary>最高响应比优先 Highest Response Ratio Next（HRRN）</summary>

响应比 = 1+ 等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。
</details>

2. **交互式系统**
交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

<details>
<summary>时间片轮转 Round Robin</summary>

将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；

若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。
</details>

<details>
<summary>优先级调度算法</summary>

为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
</details>

<details>
<summary>多级反馈队列调度算法 Multilevel Feedback Queue</summary>

设置多个就绪队列1、2、3...，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。

抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。
</details>

##### 什么叫优先级反转？如何解决？
<details>
<summary>展开</summary>

高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。

解决方法：
- 优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。
- 优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。
</details>

### 什么是僵尸进程？
一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。

危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。

以下情况不会产生僵尸进程：
- 该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。
- 父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入```WNOHANG```(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；
- 子进程结束时，系统会产生```SIGCHLD```(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；
- 也可以用```signal(SIGCLD, SIG_IGN)```(signal-ignore)通知内核，表示忽略```SIGCHLD```信号，那么子进程结束后，内核会进行回收。

##### 什么是孤儿进程？
<details>
<summary>展开</summary>

一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。
</details>

### 线程同步有哪些方式？

> 为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。

- **互斥量** Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；
- **信号量** Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了**最大资源计数**和**当前可用资源计数**，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过```ReleaseSemaphore```函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；
- **事件** Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒**一个**等待中的线程，然后自动恢复为未激发状态。
- **临界区** Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。

##### 互斥量和临界区有什么区别？
<details>
<summary>展开</summary>

互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。
</details>

### 什么是协程？

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

##### 协程与线程进行比较？
<details>
<summary>展开</summary>

1. 一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。

2. 线程进程都是同步机制，而协程则是异步

3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态
</details>

<details>
<summary>什么是文件描述符？</summary>

文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

内核通过文件描述符来访问文件。文件描述符指向一个文件。
</details>

##### 什么是水平触发？什么是边缘触发？
<details>
<summary>展开</summary>

- 水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；
- 边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。
- 区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。
- 为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。
</details>

### 什么是用户态和内核态？

为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。

- 用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；
- 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。

所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用**陷阱指令**，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。

##### 为什么要分用户态和内核态？
<details>
<summary>展开</summary>

（我自己的见解：）

- 安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；
- 封装性：用户程序不需要实现更加底层的代码；
- 利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。
</details>

##### 如何从用户态切换到内核态？
<details>
<summary>展开</summary>

- 系统调用：比如读取命令行输入。本质上还是通过中断实现
- 用户程序发生异常时：比如缺页异常
- 外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序
</details>

### 什么是死锁？

在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。

### 死锁产生的必要条件？
- **互斥**：一个资源一次只能被一个进程使用；
- **占有并等待**：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；
- **非抢占**：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；
- **循环等待**：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。

### 死锁有哪些处理方法？
<details>
<summary>鸵鸟策略</summary>

直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。
</details>

<details>
<summary>死锁预防</summary>

基本思想是破坏形成死锁的四个必要条件：
- 破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；
- 破坏占有并等待条件：
    - 实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；
    - 或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；
    - 缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性；
- 破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；
- 破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。
</details>

<details>
<summary>死锁避免</summary>

动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。

> 银行家算法
</details>

<details>
<summary>死锁解除</summary>

> 如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。

死锁解除的方法：
- 利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；
- 利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；
- 利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。
</details>

### 内存管理
- 连续内存分配的算法
    - First Fit、Best Fit、循环Fit、Worst Fit
- 不连续内存分配的算法
    - 不连续内存的分配算法基于分页和分段


### 什么是分页和分段以及它们的区别？
- 页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；
- 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；
- 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。

区别：
- 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；
- 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；
- 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；
- 分段便于信息的保护和共享；分页的共享收到限制；
- 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）

### 什么是虚拟内存？
每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。
虚拟内存的优点是让程序可以获得更多的可用内存。

##### 如何进行地址空间到物理内存的映射？
<details>
<summary>展开</summary>

**内存管理单元**（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。
</details>

### 有哪些页面置换算法？
在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

- **最佳页面置换算法**OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；
- **先进先出**FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；
- **第二次机会算法**SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；
- **时钟算法** Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；
- **最近未使用算法**NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；
- **最近最少使用算法**LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。
- **最不经常使用算法**NFU：置换出访问次数最少的页面

<details>
<summary>局部性原理</summary>

- 时间上：最近被访问的页在不久的将来还会被访问；
- 空间上：内存中被访问的页周围的页也很可能被访问。
</details>

<details>
<summary>什么是颠簸现象</summary>

颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：

- 修改页面置换算法；
- 降低同时运行的程序的数量；
- 终止该进程或增加物理内存容量。
</details>

### 文件系统

##### Linux文件系统几种权限？
- 首先Linux中的文件权限的权限对象有三种，分别是拥有者owner、组用户group和其他人other，在linux命令中分别用各自的首字母来代表他们，a的话就是代表全部用户。
- 然后这三种用户每个都可以有三个基本权限，分别是r读权限、w写权限、x执行权限
- 每个用户都还可以有4个特殊权限，分别是
    - s权限，表示文件将以root身份运行
        - s权限的获得需要先满足所属的owner和group先获得x执行权限，否则s权限不会生效，并且在查看文件权限的时候，对应位置显示的是大写S而不是小写s
        - 在文件所有者的x权限上时，此时就被称为SetUid（简称SUID），当s出现在用户组（g）上就是SetGid，当s出现在其他用户（o）上就是Sticky Bit（简称SBIT）
    - t权限，就是设置粘滞位，可以让只有owner用户和root有权限删除该文件，同样如果未生效会是大写T
    - r、w、x、s和t权限的添加或者删除可以通过“chmod +/- 对应权限的字母 [filename]”命令添加
    - 文件还有i不可修改权限和a只追加权限，通过lsattr命令查看
        - i就是相当于给文件加锁，不能修改，要修改就得先去除i权限
        - a是只能追加不能删除，在日志系统很常用
    - a和i权限通过chattr +a/i [filename]命令添加
- 所以总共有7种不同的权限，然后如果我们使用带-l的ls命令查看文件的时候，文件权限那里显示的是一个10个符号的串
    - 第一个符号是代表该对象是-普通文件还是d目录文件或者l软连接等共7种文件类型（还有p管道文件、b块设备文件、c字符设备文件、s套接字文件）
    - 然后这个串后面的9个字符才是代表这个文件的权限，每三个依次代表owner、group、other的rwx权限的有无，有就出现对应字母，否则是-
    - 然后因为x权限可以是s或者t权限,并且每个文件还有自己的i和a权限的有无，所以总共的文件不同权限严格上说有2^6 * 4^3 * 3个。
    - 另外我们会用3位8进制的数来代表文件的9个字符，这里就忽略了s和t权限，相当于每个位置有对应权限，那就是1，然后每三位作为一个三位二进制的数字先算出来作为当前8进制位下的数字，所以最后是一个3位8进制的数。

##### 文件系统和磁盘有什么关系
- 磁盘属于硬件，是一种为系统提供了基本的持久化存储的设备。
- 文件系统属于操作系统的功能，以磁盘为载体，提供了一个用来管理文件的树状结构。
##### 文件系统有哪些结构
- 文件系统主要由索引节点、目录项、超级块、逻辑块组成。
- 索引节点：记录了文件的元信息，包括文件权限、文件大小、创建时间、数据的索引位置等等。索引节点是文件的唯一标识，和文件一一对应，它和文件内容一样会持久化到磁盘中保存。
- 目录项：用来记录文件的名字、索引节点的指针以及与其他目录项的关联关系。多个关联的目录项组成了文件系统的目录结构。目录项对象不会存储到磁盘中，而是被缓存起来，便于快速的解析目录。
- 超级块：存储了整个文件系统的状态，如索引节点、逻辑块的使用情况。
- 逻辑块：文件系统用来存储数据的最小单位，大小为 4 KB，一般由 8 个连续的扇区组成（磁盘读写的最小单位是扇区，大小为 512B），多个逻辑块组成了文件系统的数据块区。
##### 什么是虚拟文件系统
- 虚拟文件系统（VFS）是操作系统在用户层与文件系统之间引入的一个抽象层，屏蔽了不同文件系统之间的差异，定义了一组标准的系统调用接口，为用户提供了统一访问文件的方式。
- VFS 定义了一组所有文件都支持的数据结构和标准接口，这样，用户和其他内核子系统只需要跟 VFS 提供的统一接口交互就可以了，而不需要关心底层各种文件系统的实现细节。

### 5种IO模型

- 阻塞IO
    - 阻塞IO就是进程调用recvfrom函数接收数据并阻塞进程，直到接收完数据再解除阻塞
    - 优点：流程简单。
    - 缺点：资源利用率低，效率低。
- 非阻塞IO
    - 发起了IO调用，若当时不满足IO条件，则调用立即返回，并循环的去查看是否满足。
    - 优点：相比较阻塞IO，资源利用率上升。
    - 缺点：需要循环的去查看是否满足条件，cpu占用较多；流程更复杂；实时性不高
- 信息驱动型IO
    - 系统先定义IO就绪的信号处理函数，等内核准备好数据后再发出信号，收到信号后线程再调用recvfrom函数读取数据
    - 优点：相较于非阻塞，IO实时性更高，IO效率更高，而且能同时监控多个文件描述符。
    - 缺点：需要自定义定义信号处理，流程会更复杂。
- 异步IO
    - 优点：对系统的利用用最为充分，IO效率最高。
    - 缺点：流程最为复杂。
- IO多路复用
    - IO多路复用就是一个线程同时监视多个描述符，一旦某个描述符就绪就通知程序进行相应的读写操作
    - 多路复用的优势不是处理速度更快，而是能处理更多的连接，本质还是非阻塞IO；
    - 实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视。一旦有文件描述符就绪（读就绪或写就绪），函数就会返回，然后该进程可以进行相应的读写操作。
    - select/poll/epoll三者的区别:
        - select
            - 将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间
            - 集合大小有限制,上限是FD_SETSIZE宏定义的数值
            - 采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符
            - 缺点：每次都要复制，开销大；集合大小有限制；轮询的方式效率较低
        - poll
            - 和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；
        - epoll
            - 通过内核和用户空间共享内存，避免了不断复制的问题;
            - 集合大小也有限制，但支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）
            - 文件描述符就绪时，采用回调机制，回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表
            - 支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数，避免了轮询，提高了效率
            - 所以epoll是效率最高的，但是select的好处在于跨平台，而epoll只能在linux系统上
    - IO多路复用适用于以下情况:
        - 一个客户同时处理多个套接字时，这种情况出现得比较少
        - 一个TCP服务器既要处理监听套接口又要处理已连接套接口的时候
        - 一个服务器既要处理TCP又要处理UDP的时候
        - 一个服务器处理多个服务或者多个协议的时候
        - 还有当客户处理多个描述字的时候，一般是交互式输入和网络套接字，这种情况是必须使用IO多路复用

    - 常见的IO多路复用的实现:select(Linux/Windows/BSD)、epoll(Linux)、poll、kqueue(BSD/Mac OS X)

- 同步和异步的概念：同步是指A事件需要等待B时间完成才能进行；而异步就是A时间的执行不依赖于B事件，5种IO模型中除了异步IO，其它都是同步IO。
- 数据读入实际上是数据从内核复制到用户空间的过程


<details>
<summary>什么时候使用select/poll，什么时候使用epoll？</summary>

当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。
</details>

##### IO调度算法有哪些

<details><summary>展开</summary>

- NOOP电梯调度算法：最简单一种调度算法
    - NOOP是No operation的前4个字母，所以顾名思义，它没有过多的优化，处理请求的策略是请求来一个处理一个
    - 当然它实际上会维护一个先进先出FIFO的队列，然后按次序执行队列中的输入输出请求
	- 如果能合并就合并
        - 如果不能合并，就会尝试排序。 如果队列上的请求都已经很老了，这个新的请求就不能插队，只能放到最后面。否则就插到合适的位置
        - 如果既不能合并，有没有合适的位置插入，就放到请求队列的最后。
    - 因为没有过多的优化，所以磁盘寻道会很频繁，所以适用场景有限，它适用于：
	- 在不希望修改输入输出请求先后顺序的场景下；
	- 或者是输入输出已经被充分优化的场景
	- 以及非旋转磁头式的磁盘设备，如SSD固态磁盘
- CFS完全公平队列算法：完全公平的调度器，一般是**默认的调度算法**
    - 这个算法会为竞争设备使用权的所有进程分配一个请求队列和一个时间片，在调度器分配给进程的时间片内，进程可以将其读写请求发送给底层块设备，当进程的时间片消耗完，进程的请求队列将被挂起，等待调度。
    - 每个进程的时间片和每个进程的队列长度取决于进程的IO优先级，每个进程都会有一个IO优先级，CFQ调度器将会将其作为考虑的因素之一，来确定该进程的请求队列什么时候可以获取块设备的使用权。
    - IO优先级从高到低可以分为三大类: RT(real time)、 BE(best try)、 IDLE(idle)
    - 其中RT和BE又可以再划分为8个子优先级，共17个优先级。可以通过ionice 去查看和修改。
    - 优先级越高，被处理的越早，用于这个进程的时间片也越多，一次处理的请求数也会越多。
- DeadLine最后期限算法：
    - DeadLine在CFQ的基础上，解决了IO请求饿死的极端情况。
    - 它保证对于既定的 IO 请求以最小的延迟时间
    - 除了CFQ本身具有的IO排序队列之外，DEADLINE额外分别为读IO和写IO提供了FIFO队列。
    - 它维护3个队列。
        - 第一个队列和电梯算法一样，尽量按照物理位置排序。
        - 第二个队列和第三个队列都是按照时间排序，不同的是一个是读操作一个是写操作。
    - 之所以区分读和写是因为
        - 设计者认为如果应用程序发了一个读请求，一般就会阻塞到那里，一直等到的结果返回。
        - 而写请求则不是通常是应用请求写到内存就结束的，还需要由后台进程再写回磁盘。应用程序一般不等写完成就继续往下走。
        - 所以读请求应该比写请求有更高的优先级。
    - 在这种设计下，每个新增请求都会先放到第一个队列，算法和电梯算法方式一样FIFO，同时也会增加到读或者写队列的尾端。
        - 这样首先处理一些第一队列的请求，同时检测第二/三队列前几个请求是否等了太长时间，如果已经超过一个阀值，就会去处理一下。
        - 这个阀值对于读请求是5ms， 对于写请求是5s.
    - DeadLine适用于 I/O 比较频繁的场景，如数据库。
- Anticipatory预期算法
    - 预测算法是基于预测的I/O算法，和最后期限算法类似，维护了三个队列。
    - 但是此算法在处理完一个I/O请求之后不会立即返回处理下一个请求，而是为每个读IO都设置了6ms的等待时间窗口，等待期间如果有新来的相邻扇区的请求，会直接处理此新来的相邻扇区的请求。当等待时间结束后，才会处理下一个队列的请求。
    - 预测算法适合写入较多的环境，不适合MySQL等随机读取较多的数据库环境。
</details>

##### 什么是DMA技术
- DMA（Direct Memory Access，直接存储器访问），是一种内存访问技术。可以在不需要 CPU 参与的情况下实现内存的读取或写入，因为不依赖 CPU 的大量中断负载，因而可以实现数据的快速传送，提高系统的并发性能。
- DMA 的传输过程必须经过 DMA 请求，DMA 响应，DMA 传输，DMA 结束 4 个步骤：
- DMA 请求：CPU 对 DMA 芯片进行设置，说明需要传送的字节数，有关的设备和内存地址，然后启动 DMA；
- DMA 响应：DMA 向 CPU 请求总线控制权，CPU 处理完当前总线数据后就让出总线；
- DMA 传输：DMA 控制器 直接控制内存与 I/O 接口进行数据传输；
- DMA 结束：DMA 传输结束后，把总线控制权交还给 CPU，并向 I/O 接口发送结束信号.
##### 传统的I/O方式需要几次拷贝及具体过程
- 传统的 I/O 方式需要经过四次拷贝才能把磁盘上的数据输出到网络端口
1.执行 read 系统调用，从用户态切换到内核态，CPU 向 DMA 控制器芯片下发指令，将磁盘数据通过直接内存访问的方式拷贝到内核缓冲区中；
2.CPU 接收到 DMA 结束拷贝的信号，将内核缓冲区的数据拷贝到用户缓冲区中，read 调用结束，返回到用户态；
3.用户程序执行 write 系统调用，从用户态切换到内核态，CPU 将数据从用户缓冲区中拷贝到Socket 发送缓冲区中；
4.CPU 下发指令，让 DMA 控制器来处理数据，将 Socket 发送缓冲区的数据拷贝到网卡进行网络传输，write 调用结束。
##### 什么是零拷贝技术
- 零拷贝指计算机不需要先将数据从一个内存区域复制到另外一个内存区域，从而减少系统调用切换、减少拷贝次数，从而减少 CPU 的执行时间和负载。
- 实现零拷贝主要用到的是 DMA 数据传输技术和内存映射技术。
- 零拷贝有几种实现方式，如下：
    - mmap + write：mmap 是一个系统调用，主要作用就是将用户缓冲区与内核中的读缓冲区进行映射，映射后这一步就不需要进行数据拷贝了，而 write 操作实际上是从内核读缓冲区中把数据拷贝到 Socket 发送缓冲区，整个过程减少了一次拷贝操作，但是系统调用切换没有减少。
    - sendfile：sendfile 同样省去了将数据在内核和用户空间中拷贝，与 mmap 不同的是，sendfile 不需要借助 write 调用，而是一次完整的内核拷贝过程，减少了两次 CPU 上下文切换。
    - sendfile + DMA gather copy：对 sendfile 系统调用做了修改，引入了 gather 操作，不需要将内核缓冲区的数据拷贝到 Socket 中，而是将它对于的数据描述信息（内存地址、文件描述符，文件长度等）记录到 Socket 缓冲区中，最后由 DMA 根据这些文件描述信息从内核读缓冲区中找到数据，直接拷贝到网卡设备中。
    - splice：splice 系统调用可以在内核空间的读缓冲区和网络缓冲区之间建立管道（pipeline），从而避免了两者之间的 CPU 拷贝操作。
- 无论是传统 I/O 拷贝方式还是引入零拷贝的方式，2 次 DMA Copy 是都少不了的，因为两次 DMA 都是依赖硬件完成的。下面从 CPU 拷贝次数、DMA 拷贝次数以及系统调用几个方面总结一下上述几种 I/O 拷贝方式的差别。
<img src="_v_images/$_14FDQOT}MWNSTQRZUPLUG.png" width=540px></img>

### 磁盘调度
过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：

- 先来先服务
- 最短寻道时间优先
- 电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

### 系统与系统调用

##### CPU由哪几部分组成
- 由4部分：运算器、控制器、寄存器、高速缓存
##### 32位操作系统和64位操作系统的区别
(待整合)
https://zhidao.baidu.com/question/244802098.html
##### 什么是系统调用
- 系统调用就是能让程序通过它去调用或者实现各种系统功能的方法，就是沟通用户程序和硬件设备的接口
- 系统调用实际上是内核中的一些C函数，它们都以sys开头的，如sys_mkdir()。它们通过一个指令int 0x80（软中断）把控制权交给内核，即进入特权级执行。int 0x80指令会使“执行”跳转到系统调用在内核中定义的入口地址。这个位置是唯一确定的，也就是system_call。
##### 系统调用和一般调用的区别
- 运行在不同的系统状态——调用程序是运行在用户态，而被调用程序是运行在系统态。
- 状态的转换通过软中断进入
    - 一般的过程调用并不涉及到系统状态的转换，可直接由调用过程转向被调用过程。
    - 系统调用不允许由调用过程直接转向被调用过程。
    - 通常都是通过软中断机制，先由用户态转换为系统态，经核心分析后，才能转向相应的系统调用处理子程序。
- 返回问题。
    - 在采用了抢占式(剥夺)调度方式的系统中，在被调用过程执行完后，要对系统中所有要求运行的进程做优先权分析。当调用进程仍具有最高优先级时，才返回到调用进程继续执行；否则，将引起重新调度，以便让优先权最高的进程优先执行。此时，将把调用进程放入就绪队列。
- 嵌套调用。
    - 像一般过程一样，系统调用也可以嵌套进行，即在一个被调用过程的执行期间，还可以利用系统调用命令去调用另一个系统调用。当然，每个系统对嵌套调用的深度都有一定的限制，例如最大深度为
##### 系统调用有哪几种
- 对于一般通用的操作系统，系统调用有：进程控制、文件操纵、通信管理和系统维护等几大类。
##### 系统调用的意义
- 用户程序通过系统调用来使用硬件，而不用关心具体的硬件设备，这样大大简化了用户程序的开发。
    - 比如：用户程序通过write()系统调用就可以将数据写入文件，而不必关心文件是在磁盘上还是软盘上，或者其他存储上。
- 系统调用使得用户程序有更好的可移植性。
    - 只要操作系统提供的系统调用接口相同，用户程序就可在不用修改的情况下，从一个系统迁移到另一个操作系统。
- 系统调用使得内核能更好的管理用户程序，增强了系统的稳定性。
    - 因为系统调用是内核实现的，内核通过系统调用来控制开放什么功能及什么权限给用户程序。
    - 这样可以避免用户程序不正确的使用硬件设备，从而破坏了其他程序。
- 系统调用有效的分离了用户程序和内核的开发。
##### 系统调用是怎么实现的或者说过程
- 系统启动后，经过引导和实模式下的初始化，进入保护模式下的核心初始化，执行head.s。其中的startup_32代码段中调用Setup_idt。Setup_idt的功能是建立一个空的且具有256个项的中断向量表。
- 接着系统转入start_kernel()模块。在该模块中，调用trap_init()初始化中断向量表，并且把系统调用system_call项注册为0x80号中断的中断服务程序。
- 所以系统调用就是通过中断服务程序去完成的

<div>
<img src="_v_images/20191202162008435_14938.png" width=540px></img>
</div>

### 其它

##### 大小端模式
- 大小端模式是指字节数据的两种存储顺序
    - 大端模式是指数据的高字节存储在低地址中，低字节存储在高地址中，存储的方式就跟人读取数据是从高位往低位读的顺序是一样的
    - 小端模式是指数据的低字节存储在低地址中，高字节存储在高地址中，存储的方式跟逻辑上的顺序是一致的
- 一般来说，操作系统的字节序是小端模式，而通讯协议是大端模式，以便计算机通讯的时候达成一致的协议，来解析数据
